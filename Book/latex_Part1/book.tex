%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

%\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]

\newcommand{\bra}[1]{\langle #1|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\braket}[2]{\langle #1|#2\rangle}
\newcommand{\ketbra}[2]{| #1\rangle \langle #2 |}
\newcommand{\Hil}{{\cal H}}
\newcommand{\Lin}{\hbox{Lin}}
\newcommand{\R}{{\mathbb R}}
\newcommand{\C}{{\mathbb C}}
\newcommand{\V}{{ V}} 
\newcommand{\tr}{{\rm tr}} 


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Las reglas del juego}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Curso de Introducción a la Computación Cuántica}
\date{Feb 13, 2024}
\release{}
\author{Javier Mas Solé}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{docs/index::doc}}


\sphinxAtStartPar
Aquí vamos a recopilar una serie de commando últiles para JupyterBooks.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Las reglas del juego

\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_01_formalismo_matematico_myst::doc}]{\sphinxcrossref{Formalismo Matemático}}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst::doc}]{\sphinxcrossref{Números Complejos}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst::doc}]{\sphinxcrossref{Vectores}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst::doc}]{\sphinxcrossref{Operadores}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst::doc}]{\sphinxcrossref{Tensores}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst::doc}]{\sphinxcrossref{Probabilidades}}}

\end{itemize}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst::doc}]{\sphinxcrossref{Fundamentos de Mecánica Cuántica}}}

\end{itemize}
\end{itemize}

\sphinxstepscope
\begin{quote}

\sphinxAtStartPar
Feb 13, 2024 | 17 words | 0 min read
\end{quote}


\chapter{Formalismo Matemático}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_01_formalismo_matematico_myst:formalismo-matematico}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_01_formalismo_matematico_myst:sec-formalismo-matematico}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_01_formalismo_matematico_myst::doc}}
\sphinxAtStartPar
Aquí vamos a explicar las herramientas matemáticas necesarias para la computación cuántica.
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst::doc}]{\sphinxcrossref{Números Complejos}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst::doc}]{\sphinxcrossref{Vectores}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst::doc}]{\sphinxcrossref{Operadores}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst::doc}]{\sphinxcrossref{Tensores}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst::doc}]{\sphinxcrossref{Probabilidades}}}

\end{itemize}

\sphinxstepscope
\begin{quote}

\sphinxAtStartPar
Feb 13, 2024 | 4 min read
\end{quote}


\begin{wrapfigure}{r}{0.150\linewidth}
\centering
\noindent\sphinxincludegraphics[width=0.150\linewidth]{{Logo_TalentQ_Azul}.png}
\end{wrapfigure}


\section{Números Complejos}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:numeros-complejos}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst::doc}}
\sphinxAtStartPar

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ../../macro\PYGZus{}tQ.py
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{macro\PYGZus{}tQ} \PYG{k}{as} \PYG{n+nn}{tQ}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k}{as} \PYG{n+nn}{la}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,}\PYG{n}{Markdown}\PYG{p}{,}\PYG{n}{Latex}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{array\PYGZus{}to\PYGZus{}latex}
\PYG{k+kn}{import} \PYG{n+nn}{copy} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Introducción}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:introduccion}}
\sphinxAtStartPar
La mecánica cuántica guarda una relación muy estrecha con los número complejos. Para introducirlos, empezaremos recordando que un número real, al cuadrado, \sphinxstyleemphasis{siempre} da un resultado positivo
\begin{equation*}
\begin{split}a^2 >0\end{split}
\end{equation*}
\sphinxAtStartPar
por ejemplo \(~~2^2 =  4~~\) pero también \(~~(-2)^2 = 4~~\). Por eso, la raíz cuadrada de un número real \sphinxstyleemphasis{sólo} existe si dicho número es positivo.

\sphinxAtStartPar
Por ejemplo \(\sqrt{4}=\pm 2\), mientras que
\begin{equation*}
\begin{split}\sqrt{-4}= \, ?\end{split}
\end{equation*}
\sphinxAtStartPar
\sphinxstylestrong{Pregunta}: \(~~\) ¿cómo podríamos definir la raíz cuadrada de un número real negativo?

\sphinxAtStartPar
\sphinxstylestrong{Respuesta}: para hacerlo, es necesario ampliar el conjunto de los números reales.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: número \(i\)

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
se postula la existencia de un nuevo número, \(~i\), que es la solución única de la ecuación \(~\)
\begin{equation*}
\begin{split} i^2 = -1\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Equivalentemente podíamos haber requerido que  \(\i = \sqrt{-1}\).

\sphinxAtStartPar
Con esto podemos ahora encontrar la raíz de cualquier número negativo. Por ejemplo, \(-4\)
\begin{equation*}
\begin{split}
(2i)(2i) = 4 i^2 = - 4
\end{split}
\end{equation*}
\sphinxAtStartPar
y \(2i\) será la raíz buscada.

\sphinxAtStartPar
Con el número \(i\) se opera igual que con los números reales
\begin{equation*}
\begin{split} i + i = 2i \end{split}
\end{equation*}\begin{equation*}
\begin{split} i - i = 0 \end{split}
\end{equation*}\begin{equation*}
\begin{split} i + 2i = 3 i\end{split}
\end{equation*}\begin{equation*}
\begin{split}i^3  = i*i*i = i^2 * i = -i\end{split}
\end{equation*}\begin{equation*}
\begin{split}\frac{i}{i} = 1\end{split}
\end{equation*}
\sphinxAtStartPar
Observar que el \sphinxstyleemphasis{inverso multiplicativo}  \(1/i\) también es \(-i\)
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_01_Numeros_Complejos_myst:bc7d0c4d-f5a5-4ced-8876-c1ee9f3d4287}\begin{eqnarray}
\frac{i}{i}  &=&   1 \nonumber\\
i (-i) &=& - i^2  =  1
\end{eqnarray}
\sphinxAtStartPar
por tanto hay una identificación importante
\begin{equation*}
\begin{split} -i = \frac{1}{i} \end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Resumen}

\sphinxAtStartPar
La solución al problema planteado consiste en extender el cuerpo de los números reales \({\mathbb R}\) al de los complejos \({\mathbb C}\) que, ahora, incluyen el número \(i\)
\end{sphinxadmonition}


\subsection{Formas cartesiana y polar}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:formas-cartesiana-y-polar}}

\subsubsection{Forma Cartesiana}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:forma-cartesiana}}
\sphinxAtStartPar
Un \sphinxstyleemphasis{número complejo}, \(z \in {\mathbb C}\), se representa en \sphinxstyleemphasis{forma cartesiana}  mediante dos
números reales \(x,y\in {\mathbb R}\)
\begin{equation*}
\begin{split}
z = x + \i y   ~~~~ \hbox{donde}~~~ 
\left\{\begin{array}{cl} x &\hbox{es la }   parte~ real\\
y & \hbox{es la } parte~imaginaria
\end{array}
\right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Un número complejo se representa  en el \sphinxstylestrong{plano complejo}: la parte real  en el \sphinxstyleemphasis{eje horizontal}, y la parte imaginaria  en el \sphinxstyleemphasis{eje vertical}


\paragraph{Numeros complejos en python:}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:numeros-complejos-en-python}}
\sphinxAtStartPar
En \sphinxstyleemphasis{python}, el número  imaginario \(\i\) se representa con la letra j.

\sphinxAtStartPar
Añadiendo +0j convertimos un float en un complex

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{isinstance}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{0}\PYG{n}{j}\PYG{p}{,}\PYG{n+nb}{complex}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
True
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Forma cartesiana\PYGZsq{}\PYGZsq{}\PYGZsq{}} 
\PYG{n}{z} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Extraemos las partes real e imaginaria\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{x}\PYG{o}{=}\PYG{n}{z}\PYG{o}{.}\PYG{n}{real}
\PYG{n}{y}\PYG{o}{=}\PYG{n}{z}\PYG{o}{.}\PYG{n}{imag}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z=x+iy=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{x} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{y}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Representación en el plano complejo \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}esta función está en archivo: macro\PYGZus{}CURSO.py  \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Representación en el plano complejo \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{right}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{up}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
z=x+iy= (\PYGZhy{}3+1j)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{cc6c12bdcc51c6b0ee10a127385b04a19dccc57a560d7b2f682ce26ddf67d316}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Forma Polar}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:forma-polar}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema: Fórmula de Euler

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Dado un ángulo \(\theta \in (0,2\pi)\) las dos expresiones siguientes son equivalentes
\begin{equation*}
\begin{split}
\cos\theta + i \sin \theta = e^{i\theta} 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Demostración}

\sphinxAtStartPar
La demostración de la Fórmula de Euler viene de expandir ambos miembros en serie de Taylor en torno a \(\theta = 0\) y comprobar que ambas series son iguales
\begin{equation*}
\begin{split}
\begin{array}{rcl}
e^{i\theta} &=& 1 + \i\theta + \frac{1}{2}(\i\theta)^2 + \frac{1}{3!}(\i\theta)^3+\, ... \\
    &=& 1 -\frac{1}{2}\theta^2 ~+~ ... ~+~ \i \left(\theta - \frac{1}{3!} \theta^3+ \, ...\right) \\
    &=& \cos \theta  + i \sin \theta 
\end{array} 
\end{split}
\end{equation*}
\sphinxAtStartPar
El número \(z=x + \i y\) se puede representar en \sphinxstyleemphasis{forma polar}
\begin{equation*}
\begin{split}
z = \rho e^{i\theta} = \rho (\cos\theta + \i \sin\theta)  
\end{split}
\end{equation*}
\sphinxAtStartPar
de donde obtenemos las componentes cartesianas
\begin{equation*}
\begin{split}x=\rho\cos\theta ~~,~~y=\rho\sin\theta\end{split}
\end{equation*}
\sphinxAtStartPar
y por tanto \(\rho^2 = x^2 + y^2\)

\sphinxAtStartPar
Los números reales \(\rho\) y \(\theta\) se denominan \sphinxstyleemphasis{módulo} y \sphinxstyleemphasis{fase}.

\sphinxAtStartPar
Las fases \(\theta\) y \(\theta+ 2\pi\) representan el \sphinxstyleemphasis{mismo} número complejo
\begin{equation*}
\begin{split}
z = \rho e^{i\theta} = \rho e^{i(\theta + 2\pi)} 
\end{split}
\end{equation*}
\sphinxAtStartPar
Ello se debe a que las funciones \(\cos \theta\) y \(\sin\theta\) son periódicas
\begin{equation*}
\begin{split}
\sin\theta  = \sin(\theta + 2\pi)~~~~~~~\cos\theta  = \cos(\theta +2\pi)
\end{split}
\end{equation*}
\sphinxAtStartPar
En forma polar la \sphinxstyleemphasis{conjugación compleja} se obtiene \sphinxstyleemphasis{cambiando el signo} de la fase
\begin{equation*}
\begin{split}
z = \rho e^{i\theta} ~\rightarrow ~z^* = \rho e^{-i\theta} = \rho \cos\theta - \i \rho \sin\theta \hspace{4cm}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Forma polar\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{r}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{n}{th}\PYG{o}{=}\PYG{l+m+mf}{3.5}
\PYG{n}{z} \PYG{o}{=} \PYG{n}{r}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{n}{th}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{=}\PYG{n}{z}\PYG{o}{.}\PYG{n}{real}
\PYG{n}{y}\PYG{o}{=}\PYG{n}{z}\PYG{o}{.}\PYG{n}{imag}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z=r exp(i th)=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}


\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Dibujamos en el plano complejo \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{right}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{up}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}1.8729133745815927\PYGZhy{}0.7015664553792397j)
z=r exp(i th)= (\PYGZhy{}1.873\PYGZhy{}0.702j)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{24d2934c8447933b46f8744afc0a9593907c2d22b9b81b2d2cac68581721e39f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Usar la forma polar es útil en situaciones en las que aparecen productos y potencias del número \(i\)
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_01_Numeros_Complejos_myst:84a1211f-117f-444c-a7ff-2be014e4697e}\begin{eqnarray}
i &=& e^{i\pi/2} \\ \rule{0mm}{10mm}
-1 &=& e^{i\pi} \\ \rule{0mm}{10mm}
i &=& e^{3i\pi/2} =e^{-i\pi/2} \\  \rule{0mm}{10mm}
i^i &=& (e^{i\pi/2})^i = e^{i^2 \pi/2} = e^{-\pi/2}  \\  \rule{0mm}{10mm}
i^{2+i} &=& (e^{i\pi/2})^{(2+i)}= e^{i\pi/2(2+i)} = e^{i\pi} e^{-\pi/2} = -e^{-\pi/2}  \rule{0mm}{10mm}
\end{eqnarray}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Haz una lista de 10 números (fases) \(\theta_i, ~i=0,...,9\), equi\sphinxhyphen{}espaciadas entre 0 y 2\(\pi\) y pinta los números complejos \(z_i = r \exp(i \theta_i)\) y sus complejos conjugados, \(z^*_i\).
\end{sphinxadmonition}


\subsubsection{Conversión entre formas cartesiana y polar}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:conversion-entre-formas-cartesiana-y-polar}}
\sphinxAtStartPar
La conversión de la representación \sphinxstyleemphasis{polar a cartesiana} es muy sencilla
gracias a las fórmula de Euler
\begin{equation*}
\begin{split}
z = r e^{i\theta} = x + i y ~~~\hbox{ con }  ~~~\left\{\begin{array}{l} x=r \cos \theta \\ \rule{0mm}{4mm} y = r\sin \theta
\end{array} \right.
\end{split}
\end{equation*}
\sphinxAtStartPar
La conversión inversa, \sphinxstyleemphasis{de cartesiana a polar} es un poco más delicada. Formalmente sería
\begin{equation*}
\begin{split}
z = x + i y  = r e^{i\theta} ~~~ \hbox{ con } ~~~ \left\{\begin{array}{l} r=\sqrt{x^2+y^2} \\  \rule{0mm}{4mm} \theta = \arctan(y/x)
\end{array} \right.
\end{split}
\end{equation*}
\sphinxAtStartPar
A la hora de la verdad hay que fijar el signo de la función \(\arctan(y/x)\). La siguiente función examina esto mirando a los signos de \(x\) y de \(y\) para saber en qué cuadrante estamos.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Conversión de Cartesianas a Polares}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{def} \PYG{n+nf}{cartes2polar}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{r} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}    
    \PYG{n}{y} \PYG{o}{=} \PYG{n}{z}\PYG{o}{.}\PYG{n}{imag}
    \PYG{n}{x} \PYG{o}{=} \PYG{n}{z}\PYG{o}{.}\PYG{n}{real}
    
    \PYG{k}{if} \PYG{n}{r}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{el número 0+i0 no admite representación polar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
        \PYG{n}{th}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{indefinido}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{k}{elif} \PYG{n}{x}\PYG{o}{==}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{y}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{:} 
        \PYG{n}{th}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{k}{elif} \PYG{n}{x}\PYG{o}{==}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{th}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{k}{elif} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{y}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{th}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arctan}\PYG{p}{(}\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{p}{)}
    \PYG{k}{elif} \PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{y}\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{th}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arctan}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{p}{)}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mi}{2}
    \PYG{k}{elif} \PYG{n}{x}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{:}
        \PYG{n}{th}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arctan}\PYG{p}{(}\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{p}{)}\PYG{o}{+}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}
    \PYG{k}{elif} \PYG{n}{x}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0} \PYG{o+ow}{and} \PYG{n}{y}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{0}\PYG{p}{:}
         \PYG{n}{th}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arctan}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{n}{y}\PYG{o}{/}\PYG{n}{x}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mf}{2.}       
            
    \PYG{k}{return} \PYG{n}{r}\PYG{p}{,}\PYG{n}{th}

\PYG{c+c1}{\PYGZsh{}el signo correcto también se puede conseguir usando la funcion np.arctan2(x,y)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Calcula  la forma polar del número complejo \(z = 4 + 3 i\) a mano y verificalo con la función que acabamos de definir
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A la inversa no es necesario definir ninguna funcion, ya que numpy directamente escribe un numero complejo en forma cartesiana}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{z} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{z}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(2.63+1.44j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Conjugacion compleja}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:conjugacion-compleja}}
\sphinxAtStartPar
Todo número complejo, \(z\), lleva \sphinxstyleemphasis{asociado} otro, \(z^*\), denominado el \sphinxstyleemphasis{complejo conjugado} que se obtiene cambiando \(\i \to -\i\)
\begin{equation*}
\begin{split}
z = x+\i y ~~~~\leftrightarrow~~~~ z^* = x - \i y \hspace{2cm}
\end{split}
\end{equation*}
\sphinxAtStartPar
Es evidente que \((z^*)^* = z\), es una \sphinxstyleemphasis{involución}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Conjugacion compleja\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{zc} \PYG{o}{=} \PYG{n}{z}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z*=(x+iy)*=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{z}\PYG{o}{.}\PYG{n}{real} \PYG{o}{+}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{zc}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Representación en el plano complejo \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{right}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{up}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{y}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{zc}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{zc}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
z*=(x+iy)*= (2.6327476856711183\PYGZhy{}1.438276615812609j)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{7137edc15c93765a6c42d790ac73de60400de82f99ddbe7f3e442c150156301b}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Operaciones básicas}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:operaciones-basicas}}
\sphinxAtStartPar
Los numeros complejos \({\mathbb C}\) forman una estructura matemática denominada \sphinxstyleemphasis{cuerpo}. Esto  quiere decir que admiten dos operaciones \sphinxstyleemphasis{internas}: la \sphinxstylestrong{suma} y la \sphinxstylestrong{multiplicación}. Vamos a estudiarlas por separado


\subsubsection{Suma}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:suma}}
\sphinxAtStartPar
En representación \sphinxstyleemphasis{cartesiana} se \sphinxstyleemphasis{suman las partes real e imaginaria por separado}
\begin{equation*}
\begin{split}
(a + \i b) + (c + \i d) = (a+c) + \i (b+d)
\end{split}
\end{equation*}
\sphinxAtStartPar
La resta es obvia, ya que \(a,b,c,d\) pueden ser números negativos.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Suma en cartesianas\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{z1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{4}\PYG{n}{j}
\PYG{n}{z2} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{n}{j}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Suma y resta\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{z1}\PYG{o}{+}\PYG{n}{z2}
\PYG{n}{zd} \PYG{o}{=} \PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z2}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z1+z2=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zs}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z1\PYGZhy{}z2=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zd}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{************************************}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}



\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{right}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{up}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}cambiar las dimensiones para que encuadrar la figura}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z1}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{zd}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{zd}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
z1+z2= (3+6j)
z1\PYGZhy{}z2= (\PYGZhy{}1+2j)
************************************
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{c2f818a81eb38f0eca639ca2af11ed13eb894bf388d6ac7d92cdd1250c37453a}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
En \sphinxstyleemphasis{forma polar}, la suma de dos números complejos no admite ninguna simplificación, y deben transformarse primeramente a forma cartesiana, para sumarse.
\begin{equation*}
\begin{split}
z + w = \rho e^{i\theta} + \sigma e^{i\phi} = (\rho\cos\theta + \sigma\cos\phi) + i(\rho\sin\theta +  \sigma\sin\phi) \hspace{6cm}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{python directamente escribe un numero complejo en forma cartesiana}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{z1} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{z2} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{l+m+mf}{0.7}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Suma y resta\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{z1}\PYG{o}{+}\PYG{n}{z2}
\PYG{n}{zd} \PYG{o}{=} \PYG{n}{z1}\PYG{o}{\PYGZhy{}}\PYG{n}{z2}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z1+z2=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{zs}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z1\PYGZhy{}z2=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{zd}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{************************************}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{right}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{up}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}cambiar las dimensiones para que encuadrar la figura}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z1}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{zd}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{zd}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
z1+z2= (3.3976+0.7941j)
z1\PYGZhy{}z2= (1.8679+2.0825j)
************************************
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{5f34de7bc2e7a797acca812bf92449a1cc26e7c67344b842adfba662eeccbb1d}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Multiplicación}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:multiplicacion}}
\sphinxAtStartPar
En \sphinxstyleemphasis{forma cartesiana} la multiplicación es complicada, debiendo multiplicarse todos los factores entre sí, y
teniendo en cuenta que \(\i^2= -1\)
\begin{equation*}
\begin{split}
(a + \i b) (c + \i d) =ac +  a\i d +\i bc +\i^2 bd = (ab - bd) + \i(ac + bd)\hspace{6cm}
\end{split}
\end{equation*}
\sphinxAtStartPar
Para hallar el producto de dos números complejos \(z=r e^{i\theta}\) y \(w=s e^{i\phi}\) escritos en forma polar, se multiplican los módulos y se suman las fases
\begin{equation*}
\begin{split}
z w = r e^{i\theta} s e^{i\phi} = rs\,   e^{i(\theta + \phi)} 
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z1} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\PYG{n}{z2} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{l+m+mf}{0.7}\PYG{p}{)}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Producto\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z1*z2 = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{*}\PYG{n}{z2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z1**3 = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n+nb}{pow}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{************************************}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
z1*z2 =  (2.9402\PYGZhy{}0.596j)
z1**3 =  (\PYGZhy{}722+103j)
************************************
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Valor absoluto}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:valor-absoluto}}
\sphinxAtStartPar
El cuadrado de un número real \(a\in {\mathbb R}\) es otro número real positivo \(a^2 >0\). Ello nos permite definir
el valor absoluto \(|a| = \sqrt{a^2}\) que es el mismo para \(a\) y para \(-a\).

\sphinxAtStartPar
Esto no sucede con un número complejo \(z\). \(~\) En efecto,
\begin{equation*}
\begin{split}z^2 = x^2 - y^2 +2\i xy\end{split}
\end{equation*}
\sphinxAtStartPar
es complejo.\(~\) Sin embargo, el producto de un número por su conjugado es un número \sphinxstyleemphasis{real} y \sphinxstyleemphasis{positivo}
\begin{equation*}
\begin{split}
z z^*  = (x + \i y) (x-\i y) = x^2 + y^2 >0
\end{split}
\end{equation*}
\sphinxAtStartPar
Ello nos permite definir el \sphinxstyleemphasis{valor absoluto} de un número complejo
\begin{equation*}
\begin{split}
|z| = \sqrt{z z^*} = \sqrt{x^2 + y^2}
\end{split}
\end{equation*}
\sphinxAtStartPar
El \sphinxstyleemphasis{valor absoluto} de una fase es 1
\begin{equation*}
\begin{split}
|e^{i\theta}| = \sqrt{ e^{i\theta}   e^{-i\theta}}=\sqrt{ e^{i(\theta-\theta)}}=\sqrt{e^0} = 1
\end{split}
\end{equation*}
\sphinxAtStartPar
El \sphinxstyleemphasis{valor absoluto} de un número complejo con el \sphinxstyleemphasis{módulo}  escrito en forma polar
\begin{equation*}
\begin{split}
|z| = \sqrt{zz^*} = \sqrt{\rho e^{i\theta} \rho e^{-i\theta}}=\sqrt{\rho^2} = \rho
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Verifica el valor absoluto de un producto de números complejos es el producto de sus valores absolutos
\end{sphinxadmonition}


\subsubsection{División}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:division}}
\sphinxAtStartPar
Al igual que la multiplicación, en forma cartesiana, la división \sphinxstylestrong{no es simple}. Sea \(z = a+ \i b\) y \(w=c+\i d\)
\begin{equation*}
\begin{split}
\frac{z}{w} = \frac{z}{w}\frac{w^*}{w^*} = \frac{( a+ \i b)(c-\i d)}{|w|^2} = \frac{ac+bd + \i(bc-ad)}{c^2+d^2}  = \frac{ac+bd}{c^2+d^2} +\i\frac{bc-ad}{c^2+d^2}
\end{split}
\end{equation*}
\sphinxAtStartPar
En forma polar la división es tan sencilla como la multiplicación. Se toma el  cociente de los módulos y la resta de las fases
\begin{equation*}
\begin{split}
\frac{z}{w} = \frac{\rho e^{i\theta}}{\sigma e^{i\phi}} = \frac{\rho}{\sigma}
e^{i(\theta-\phi)}
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Valor absoluto\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{|z1|=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{comprobación |z1|=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{*}\PYG{n}{z1}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)} 
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{************************************}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}


\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Division\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z1/z2=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{/}\PYG{n}{z2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{comprobación z1/z2=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{*}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{z2}\PYG{o}{*}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
|z1|= 3.0
comprobación |z1|= 3.0
************************************
z1/z2= (1.08707+2.79612j)
comprobación z1/z2= (1.08707+2.79612j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Casos particulares}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:casos-particulares}}
\sphinxAtStartPar



\subsubsection{Sumas nulas}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:sumas-nulas}}
\sphinxAtStartPar
En muchas ocasiones nos encontraremos la siguiente representación del numero cero (complejo) \(0 = 0 + \i 0\)
\begin{equation*}
\begin{split}
\sum_{k=0}^{N-1} e^{2\pi \i k/N} =   e^{2\pi \i\, 0/N} +  e^{2\pi \i\, 1/N}  +~...~ +   e^{2\pi \i\, (N-2)/N}+   e^{2\pi \i\, (N-1)/N} ~=~  ~0
 \end{split}
\end{equation*}
\sphinxAtStartPar
Para convencerse de que esta identidad es cierta vamos a representar los números complejos y su suma. Puedes cambiar \(N\) y también multiplicar por un módulo constante

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} cambiar el número N}
\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{9}
\PYG{n}{rho}\PYG{o}{=}\PYG{l+m+mi}{1}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Creamos las fases\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{N}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(\PYGZsq{}lista de fases =\PYGZsq{}, np.round(lista\PYGZus{}de\PYGZus{}fases,2))}


\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Dibujamos los números complejos \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{fsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{vec} \PYG{o+ow}{in} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{p}{:}
    \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{vec}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{y}\PYG{o}{=}\PYG{n}{vec}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}draw\PYGZus{}unit\PYGZus{}circle()}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add\PYGZus{}patch}\PYG{p}{(}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{Circle}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{fill}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{)} 


\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Calculamos la suma. \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}print(lista\PYGZus{}de\PYGZus{}fases)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0+0j)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{f35cc90a75d02e5c3e0dea02f44f75e70b8fe89e063305942f97950494bfe958}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Sea  \(1\leq j \leq N-1\) un entero por el que multiplicamos todas las fases. El resultado es el mismo
\begin{equation*}
\begin{split}
\sum_{k=0}^{N-1} e^{2\pi \i j k/N} =   e^{2\pi \i\, 0/N} +  e^{2\pi \i\, j/N}  +~...~ +   e^{2\pi \i\, j(N-2)/N}+   e^{2\pi \i\, j(N-1)/N} ~=~  ~0
 \end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} cambiar el número N}
\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{9}
\PYG{n}{rho}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{3}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Creamos las fases\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{j}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{N}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(\PYGZsq{}lista de fases =\PYGZsq{}, np.round(lista\PYGZus{}de\PYGZus{}fases,2))}


\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Dibujamos los números complejos \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{fsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{vec} \PYG{o+ow}{in} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{p}{:}
    \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{vec}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{y}\PYG{o}{=}\PYG{n}{vec}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}draw\PYGZus{}unit\PYGZus{}circle()}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add\PYGZus{}patch}\PYG{p}{(}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{Circle}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{fill}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{)} 

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Calculamos la suma. \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}print(lista\PYGZus{}de\PYGZus{}fases)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(\PYGZhy{}0+0j)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{01deb8d6290f05212f629cabd30c9e11fefcf7a62a4b2457d0056f78565c935f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Sin embargo si \(j = 0, N, 2N,... = 0\,\hbox{mod} N\), entonces la suma no se anula y su valor es igual a \(N\).

\sphinxAtStartPar
Tomemos por ejemplo \(j=N\)
\begin{equation*}
\begin{split}
\sum_{k=0}^{N-1} e^{2\pi \i (3N) k/N} = \sum_{k=0}^{N-1} e^{2\pi \i  k}  =  \sum_{k=0}^{N-1} 1 =~  ~N
 \end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} cambiar el número N}
\PYG{n}{N}\PYG{o}{=}\PYG{l+m+mi}{9}
\PYG{n}{rho}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{j}\PYG{o}{=}\PYG{n}{N}
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Creamos las fases\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{j}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{N}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(\PYGZsq{}lista de fases =\PYGZsq{}, np.round(lista\PYGZus{}de\PYGZus{}fases,2))}


\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Dibujamos los números complejos \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{fsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{vec} \PYG{o+ow}{in} \PYG{n}{rho}\PYG{o}{*}\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{p}{:}
    \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{vec}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{y}\PYG{o}{=}\PYG{n}{vec}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}draw\PYGZus{}unit\PYGZus{}circle()}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{gca}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{add\PYGZus{}patch}\PYG{p}{(}\PYG{n}{plt}\PYG{o}{.}\PYG{n}{Circle}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mf}{1.}\PYG{p}{,}\PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{black}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{fill}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}\PYG{p}{)} 

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Calculamos la suma. \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}print(lista\PYGZus{}de\PYGZus{}fases)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{rho}\PYG{o}{*}\PYG{n}{lista\PYGZus{}de\PYGZus{}fases}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(9\PYGZhy{}0j)
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{78f8f6c7bdad2987eb77ffed1e71530a1d57a8cba728408deae7ffdc3035e3e3}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Modifica la lista de fases para convencerte de que todos los resultados anteriores son correctos
\end{sphinxadmonition}

\sphinxAtStartPar
Una manera de resumir todos los casos anteriores en una sola expresión involucra la función \(\delta\) de Kronecker
\begin{equation*}
\begin{split}
\delta_{ij} = \left\{ \begin{array}{rcl} 0 & \hbox{si} & i\neq 0 \\ 1 & \hbox{si} & i = j \end{array} \right.
\end{split}
\end{equation*}
\sphinxAtStartPar
Con ella podemos enunciar el siguiente resultado
\begin{equation*}
\begin{split}
\boxed{\frac{1}{N}\sum_{k=0}^{N-1} e^{2\pi \i \, j k/N} =  \delta_{j\, 0{\rm mod} N}}
\end{split}
\end{equation*}
\sphinxAtStartPar
que usaremos con profusión al estudiar la transformada de Fourier cuántica.


\subsubsection{Desigualdad triangular}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_01_Numeros_Complejos_myst:desigualdad-triangular}}
\sphinxAtStartPar


\sphinxAtStartPar
El módulo de la suma de dos números complejos verifica que
\begin{equation*}
\begin{split}
| z+w| \leq |z| + |w| 
\end{split}
\end{equation*}
\sphinxAtStartPar
Donde la igualdad sólo se verifica cuando ambos números complejos son paralelos en el plano complejo.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Comprueba que sólo cuando z1 y z2 son paralelos, se satura la desigualdad triangular\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Suma en cartesianas\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{z1} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{n}{j}

\PYG{n}{ang} \PYG{o}{=} \PYG{l+m+mf}{0.} \PYG{c+c1}{\PYGZsh{}el ángulo entre z1 y z2}
\PYG{n}{z2} \PYG{o}{=} \PYG{n}{z1}\PYG{o}{*}\PYG{p}{(}\PYG{l+m+mf}{1.2}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{ang}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Suma \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{zs} \PYG{o}{=} \PYG{n}{z1}\PYG{o}{+}\PYG{n}{z2}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{|z1|+|z2|=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{z1}\PYG{p}{)}\PYG{o}{+}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{|z1+z2|=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{+}\PYG{n}{z2}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{right}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{up}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}cambiar las dimensiones para que encuadrar la figura}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z1}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z1}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{z2}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{zs}\PYG{o}{.}\PYG{n}{imag}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
|z1|+|z2|= 4.919349550499538
|z1+z2|= 4.919349550499538
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{9a6508e64605904f903419f262c7c520b72aab54f2aa81007759cfe4a6d81422}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope
\begin{quote}

\sphinxAtStartPar
Feb 13, 2024 | 6 min read
\end{quote}


\begin{wrapfigure}{r}{0.150\linewidth}
\centering
\noindent\sphinxincludegraphics[width=0.150\linewidth]{{Logo_TalentQ_Azul}.png}
\end{wrapfigure}


\section{Vectores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:vectores}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst::doc}}
\sphinxAtStartPar


\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ../../macro\PYGZus{}tQ.py
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{macro\PYGZus{}tQ} \PYG{k}{as} \PYG{n+nn}{tQ}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,}\PYG{n}{Markdown}\PYG{p}{,}\PYG{n}{Latex}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{array\PYGZus{}to\PYGZus{}latex}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Espacio Vectorial Complejo}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:espacio-vectorial-complejo}}

\subsubsection{Definición}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:definicion}}
\sphinxAtStartPar
De forma poco rigurosa, definiremos un \sphinxstyleemphasis{vector de dimensión} \(N\) como una columna de \(N\) números complejos
\begin{equation*}
\begin{split}
|u\rangle = \begin{pmatrix} {u_1}\\ {u_2}\\ \vdots \\ {u_N} 
\end{pmatrix}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El símbolo \(\ket{u}\)  \sphinxstyleemphasis{representa} al vector y se denomina \sphinxstyleemphasis{ket} en la \sphinxstyleemphasis{notación de Dirac}

\item {} 
\sphinxAtStartPar
Los números complejos \(u_i \in {\mathbb C}\) con \(\, i=1,...,N\) se denominan \sphinxstyleemphasis{componentes} del vector \(\ket{u}\) (en una base dada).

\end{itemize}

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: Espacio Vectorial

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
La colección de todos los posibles vectores de \(N\) componentes,  con las  propiedades de suma y multiplicación forman un espacio vectorial, \(\V\) de dimension compleja \(N\)

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Es decir,  en un espacio vectorial  tenemos dos operaciones posibles:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Sumar dos vectores

\end{itemize}
\begin{equation*}
\begin{split}
 |u\rangle + \ket{v}~ =~\, 
\begin{pmatrix} {u_1}+v_1\\ {u_2}+v_2\\ \vdots \\ {u_N}+v_n \end{pmatrix} ~= ~\ket{w}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Multiplicar un vector por número complejo \(\lambda\in {\mathbb C}\)

\end{itemize}
\begin{equation*}
\begin{split}
 \lambda|u\rangle ~ =~   \begin{pmatrix} {\lambda u_1}\\ {\lambda u_2}\\ \vdots \\ {\lambda u_N} \end{pmatrix} ~\equiv~\ket{\lambda u}
\end{split}
\end{equation*}
\sphinxAtStartPar
Todo vector de \(V\) se denota mediante el símbolo \(\ket{v}\) menos uno, el \sphinxstyleemphasis{elemento neutro} que se escribe como \(0\).

\sphinxAtStartPar
La existencia de un elemento opuesto y de un elemento neutro es una de las propiedades que definen un espacio vectorial
\begin{eqnarray*}
\ket{v} + 0 &=& \ket{v} \nonumber\\
\ket{v} + \ket{\hbox{-}v} &=& \ket{v}-\ket{v} = 0 \nonumber\\
\end{eqnarray*}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
La dimensión es igual al número de cantidades (grados de libertad) que debemos fijar para especificar un vector.

\sphinxAtStartPar
Pero \(N\) números complejos equivalen a \(2N\) números reales.

\sphinxAtStartPar
Entonces, podemos decir que:\\
la dimensión compleja de un espacio vectorial complejo  \(\V\) es \(N\), o que su dimensión real es \(2N\)
\begin{equation*}
\begin{split}
{\rm dim}_{\mathbb C} \V = N ~~~~\Longleftrightarrow ~~~   {\rm dim}_{\mathbb R} \V = 2N 
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
Formalmente, este espacio vectorial es equivalente (\sphinxstyleemphasis{isomorfo}) al producto cartesiano
\begin{equation*}
\begin{split}
\V_N \sim {\mathbb C}^N = \overbrace{{\mathbb C}\times{\mathbb C}\times...{\mathbb C}}^{N}
\end{split}
\end{equation*}
\sphinxAtStartPar
formado por ristras de \(N\) números complejos \(N\)\sphinxstyleemphasis{\sphinxhyphen{}tuplas}, con la propiedad de suma y multiplicación

\sphinxAtStartPar
Adelantándonos un poco, el caso \(N=2\) es el que juega un papel fundamental en computación cuántica: un \sphinxstyleemphasis{cúbit} es un vector de \({\mathbb C}^2\). El caso \(N=d\) hablamos de \sphinxstyleemphasis{cúdit}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ qiskit tiene un visualizador }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{array\PYGZus{}to\PYGZus{}latex}

\PYG{n}{uket}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1} \PYG{o}{+} \PYG{l+m+mf}{1.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mf}{1.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
 
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{uket}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{uket}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
1 + i  \\
 2 - 3 i  \\
 2  \\
 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}(1 + i) |00\rangle+(2 - 3 i) |01\rangle+2 |10\rangle+i |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Conjugación adjunta}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:conjugacion-adjunta}}
\sphinxAtStartPar
La operación \sphinxstyleemphasis{conjugación adjunta},  \(\dagger\), es una \sphinxstyleemphasis{extensión} de la \sphinxstyleemphasis{conjugación compleja} de \({\mathbb C}\) a todos los elementos  de \(\Hil\)

\sphinxAtStartPar
Asociado a cada \sphinxstyleemphasis{ket} \(\ket{u}\), definimos un vector \sphinxstylestrong{adjunto}, o \sphinxstyleemphasis{bra} \(\bra{u}\equiv\left(\ket{u}\right)^\dagger\),  que representamos mediante un vector fila con las componentes conjugadas complejas.
\begin{equation*}
\begin{split}
\dagger \,: \quad\,|u\rangle = \begin{pmatrix} {u_1}\\ {u_2}\\ \vdots \\ {u_N} 
\end{pmatrix} ~~~~~{\rightarrow}~~~~~~ \left(\ket{u}\right)^\dagger \equiv \bra{u} =\begin{pmatrix} {u_1^*} & {u_2^*} & \cdots & {u_N^*}
\end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Consistentemente encontramos para el producto de un vector por un número complejo \(\lambda\)
\begin{equation*}
\begin{split}
\dagger \,:\quad\,  \lambda\ket{u}=\ket{\lambda u} ~~~~~{\rightarrow}~~~~~~ \left(\lambda\ket{u}\right)^\dagger=\lambda^*\bra{u} = \bra{u}\lambda^* = \bra{\lambda u}
\end{split}
\end{equation*}
\sphinxAtStartPar
ya que el producto de un vector por un número es conmutativo.

\sphinxAtStartPar
Al igual que la conjugación compleja, la conjugación adjunta es una \sphinxstyleemphasis{involución}: su aplicación sucesiva devuelve el vector original
\begin{equation*}
\begin{split}
(\ket{u}^\dagger)^\dagger =\bra{u}^\dagger =  \ket{u}
\end{split}
\end{equation*}
\sphinxAtStartPar
es decir, \(\dagger^2 = I\), el operador identidad.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{definamos un ket}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{uket}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{3}\PYG{o}{*}\PYG{l+m+mf}{1.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{uket}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(uket.shape)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{el bra asociado será una fila formada por las componentes conjugadas complejas}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ubra}\PYG{o}{=}\PYG{n}{uket}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{ubra}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}print(ubra.shape)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
1 + i  \\
 2 - 3 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{bmatrix}
1 - i & 2 + 3 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Bases}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:bases}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
En un espacio vectorial \(V\) de dimensión \(N\) una base es una colección de \(N\) vectores  \(\{\ket{e_1},...,\ket{e_N}\}\) tales que, cualquier vector \(\ket{v}\in V\) se puede expresar como una combinación lineal de ellos
\begin{equation*}
\begin{split}
\ket{v} = \sum_{i=1}^N v_i \ket{e_i}
\end{split}
\end{equation*}
\sphinxAtStartPar
Los coeficientes \(v_i\) son las componentes de \(\ket{v}\) en la base dada.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Existen \sphinxstyleemphasis{infinitas bases} en un espacio vectorial. Podemos escoger una de ellas y asociarle el siguiente conjunto de columnas
\begin{equation*}
\begin{split}
|e_1\rangle \sim \begin{pmatrix} 1 \\ 0 \\ 0\\ \vdots 
\\ 0 \\ 0 \end{pmatrix}~~~~
|e_2\rangle \sim \begin{pmatrix} 0 \\ 1 \\ 0\\ \vdots 
\\ 0 \\ 0 \end{pmatrix}~~~~~~~~~
\cdots ~~~~~~~~
|e_{N-1}\rangle \sim \begin{pmatrix} 0 \\ 0 \\ 0\\\vdots 
\\ 1 \\ 0 \end{pmatrix}~~~~
|e_N\rangle \sim \begin{pmatrix} 0 \\ 0 \\0\\ \vdots 
\\ 0 \\ 1 \end{pmatrix}
\end{split}
\end{equation*}


\sphinxAtStartPar
Cualquier vector, escrito como una combinación lineal de sus elementos adquiere la representación usual
\begin{equation*}
\begin{split}
|u\rangle ~=~ {u_1} |e_1 \rangle + {u_2} | e_2\rangle +... + {u_{ N}}|e_{ N}\rangle~=~ \sum_{i=1}^N {u_ i} |e_i\rangle \,\sim
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
\sim~ {u_1} \begin{pmatrix} 1 \\ 0 \\ 0\\ \vdots 
\\ 0 \\ 0 \end{pmatrix} \,+\,{u_2} \begin{pmatrix} 0 \\ 1 \\ 0\\ \vdots \\ 0 \\ 0 \end{pmatrix}~+~ ... ~+ ~
{u_{N-1}} \begin{pmatrix} 0 \\ 0 \\ 0\\\vdots 
\\ 1 \\ 0 \end{pmatrix}+ 
\,{u_N}\,  \begin{pmatrix} 0 \\ 0 \\0\\ \vdots 
\\ 0 \\ 1 \end{pmatrix}~~~= ~~~
  \begin{pmatrix} {u_1} \\ {u_2} \\{u_3}\\ \vdots 
\\ \,{u_{N-1}}\, \\ {u_{N}} \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Podemos usar la clase \sphinxstylestrong{Statevector} de \sphinxstyleemphasis{qiskit} para tener una expansión en la base \(\{\ket{e_i}=\ket{b(i)}\}\), donde \(b(i)\) es la representación binaria del índice \(i\). Por ejemplo \(b(3) = 11\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{quantum\PYGZus{}info} \PYG{k+kn}{import} \PYG{n}{Statevector}
\PYG{n}{uket}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[} \PYG{l+m+mf}{1.}\PYG{o}{+}\PYG{l+m+mf}{1.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[} \PYG{l+m+mf}{2.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[} \PYG{l+m+mf}{2.}\PYG{o}{+}\PYG{l+m+mf}{2.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{uket}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{Statevector}\PYG{p}{(}\PYG{n}{uket}\PYG{p}{)}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{latex}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
1 + i  \\
 2 - 3 i  \\
 2 + 2 i  \\
 -1 - i  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}(1 + i) |00\rangle+(2 - 3 i) |01\rangle+(2 + 2 i) |10\rangle+(-1 - i) |11\rangle\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Cambio de base}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:cambio-de-base}}
\sphinxAtStartPar
Existen \sphinxstyleemphasis{infinitas} bases  en un espacio vectorial de dimensión finita.
Todas ellas sirven para representar un vector arbitrario.

\sphinxAtStartPar
Consideremos dos bases
\(\{\ket{e_i}\}\) y \(\{\ket{\tilde e_j}\}\) donde \( i,j = 1,...,N\):

\sphinxAtStartPar
cualquier \sphinxstyleemphasis{elemento} (vector) de una base se puede expresar como una \sphinxstyleemphasis{combinación lineal de elementos}  de la otra
\begin{equation*}
\begin{split}
\ket{\tilde e_j} = \sum_{i=1}^N C_{ i j} \ket{e_i} ~~~~~~~j=1,..., N
\end{split}
\end{equation*}
\sphinxAtStartPar
Los coefficientes  \(C_{ i j}\in {\mathbb C}\) constituyen la \sphinxstyleemphasis{matriz} \(C_{ij}\) de \sphinxstyleemphasis{cambio de base}

\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
La forma en que están sumados los índices
\begin{equation*}
\begin{split}
\ket{\tilde e_j} = \sum_{i=1}^N C_{\color{blue}{i} j} \ket{e_{\color{blue}{i}}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Esto hace que, si queremos escribir esta ecuación en notación matricial,  debamos poner los vectores en una fila
\begin{equation*}
\begin{split}
\begin{pmatrix} \ket{\tilde e_1} & \cdots & \ket{\tilde e_N} \end{pmatrix} = 
\begin{pmatrix} \ket{ e_1} & \cdots & \ket{e_N}\end{pmatrix}
\begin{pmatrix} C_{11} & \cdots & C_{1N} \\ \vdots & \ddots & \vdots \\ C_{N1} & \cdots & C_{NN} \end{pmatrix}
\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejemplo}

\sphinxAtStartPar
Sea una nueva base \(\{\ket{f_1},\ket{f_2}\}\) definida en términos de la antigua mediante
\begin{equation*}
\begin{split}\ket{f_1} = \frac{1}{\sqrt{2}}\left(\rule{0mm}{4mm}\ket{e_1} + i\ket{e_2}\right)~,~~\ket{f_2} = \frac{1}{\sqrt{2}}\left( \rule{0mm}{4mm}\ket{e_1} - i\ket{e_2}\right)\, .
\end{split}
\end{equation*}
\sphinxAtStartPar
La matriz de coeficientes es
\begin{equation*}
\begin{split}
C_{ij} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\ i & -i \end{bmatrix}\, ,
\end{split}
\end{equation*}
\sphinxAtStartPar
El cambio de base, usando esta matriz se escribe de forma matricial
\begin{equation*}
\begin{split}
(\ket{f_1},\ket{f_2}) = (\ket{e_1},\ket{e_2}) \cdot \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\ i & -i \end{bmatrix}
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
Un vector puede ser expandido en ambas bases
\begin{equation*}
\begin{split}~~\ket{v}  = \sum_{i} v_i \color{blue}{\ket{e_i}} = \sum_j \tilde v_j \color{magenta}{\ket{\tilde e_j}}\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=250\sphinxpxdimen]{{Descomp_ortogonal}.png}
\end{figure}

\sphinxAtStartPar
La relación entre los coeficientes se sigue de la misma matriz de cambio de base
\begin{eqnarray*}
\ket{v}  ~= ~ \sum_{i} v_i \ket{e_i} &~=~& \sum_j \tilde v_j \ket{f_j} \nonumber\\
&~=~&  \sum_j \tilde v_j \left( \sum_{i} C_{ij} \ket{e_i}\right) \nonumber \\
&~=~&  \sum_{j}\sum_{i} \tilde v_j   C_{ij} \ket{e_i} \nonumber \\
&~=~& \sum_i \left( \sum_j C_{ij} \tilde v_j \right) \ket{e_i}  \nonumber \\
\end{eqnarray*}
\sphinxAtStartPar
Comparando obtenemos la relación de coeficientes
\begin{equation*}
\begin{split}
v_i = \sum_{j} C_{i\color{black}{j}} \tilde v_{\color{black}{j}}
\end{split}
\end{equation*}
\sphinxAtStartPar
que podemos invertir
\begin{equation*}
\begin{split}
\tilde v_i = \sum_{j} C^{-1}_{i\color{black}{j}} v_{\color{black}{j}}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
La forma en que están sumados los índices hace que, en notación matricial esta operación se represente como sigue

\end{enumerate}
\begin{equation*}
\begin{split}
\begin{pmatrix} v_1\\ \vdots \\ v_n\end{pmatrix} = 
\begin{pmatrix} C_{11} & \cdots & C_{1n} \\ \vdots & \ddots & \vdots \\ C_{n1} & \cdots & C_{nn} \end{pmatrix}
\begin{pmatrix} \tilde v_1\\ \vdots \\ \tilde v_n\end{pmatrix}
\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
La misma matriz \(C\), que lleva \(\ket{e_i} \to \ket{\tilde e_i}\), lleva \(\tilde v_j \to v_j\)

\end{enumerate}
\end{sphinxadmonition}

\sphinxAtStartPar
En particular esto dice que la matriz \(C_{ij}\) se lee inmediatamente de expresar la nueva base en la antigua

\begin{sphinxadmonition}{note}{Ejemplo (continuación) }
\begin{equation*}
\begin{split}
\ket{f_1} \sim \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\i \end{bmatrix}~~~,~~~~
\ket{f_2} \sim \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\-i \end{bmatrix}~~.
\end{split}
\end{equation*}
\sphinxAtStartPar
Poniendo las dos columnas en una sola matriz, obtenemos  la matriz \(C_{ij}\) que efectúa el cambio de los vectores de la base
\begin{equation*}
\begin{split}
 \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\i \end{bmatrix} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\ i & -i \end{bmatrix}\begin{bmatrix} 1 \\0 \end{bmatrix}~~~~~,~~~~~~~
\frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\-i \end{bmatrix} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\ i & -i \end{bmatrix}\begin{bmatrix} 0 \\1 \end{bmatrix}~~~~~.~~~~~~~
\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Considera las bases ortonormales \(\{\ket{0},\ket{1}\}\) y \(\{\ket{+},\ket{-}\}\) donde \(\ket{\pm} = \frac{1}{\sqrt{2}}(\ket{0} \pm \ket{1})\).

\sphinxAtStartPar
Las componentes del vector \(\ket{u} \sim \begin{pmatrix}3\\1\end{pmatrix}\) están escritas en la primera base.

\sphinxAtStartPar
Halla las componentes de \(\ket{u}\) en la segunda.
\end{sphinxadmonition}


\subsection{Espacio de Hilbert}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:espacio-de-hilbert}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Un  espacio de Hilbert,  \({\Hil}\), es un espacio vectorial
dotado de una operación interna   denominada producto escalar.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Producto Escalar}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:producto-escalar}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
El producto escalar de dos vectores \(\ket{u}\) y \(\ket{v}\) es un número complejo
\(a\in{\mathbb C}\)\\
que denotamos braket
\begin{equation*}
\begin{split}a \equiv \braket{u}{v} \end{split}
\end{equation*}
\sphinxAtStartPar
si verifica las dos propiedades siguiente
\begin{itemize}
\item {} 
\sphinxAtStartPar
linealidad: \(\to \bra{u}\big(\ket{v}+\ket{w}\big) = \braket{u}{v} + \braket{u}{w}\)

\item {} 
\sphinxAtStartPar
hermiticidad: \(\to \braket{v}{u} = \braket{u}{v}^*\)

\item {} 
\sphinxAtStartPar
positividad: \(\braket{u}{u} >0\) para todo ket \(\ket{u}\neq 0\)

\item {} 
\sphinxAtStartPar
no\sphinxhyphen{}degeneración: \(~\) si  \(\braket{u}{v} = 0\) para todo \(\bra{u}\), entonces necesariamente \(\ket{v}=0\)

\end{itemize}

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Combinando ambas propiedades, el producto escalar también es lineal en el primer argumento
\begin{equation*}
\begin{split}(\bra{u}+\bra{w})\ket{v} = \braket{u}{v} + \braket{w}{v}\end{split}
\end{equation*}
\sphinxAtStartPar
Notar que la propiedad de hermiticidad es precisamente la extensión de la conjugación compleja de la que hablábamos al definir la aplicación \sphinxstyleemphasis{adjunta}
\begin{equation*}
\begin{split}
\braket{u}{v}^* = \braket{u}{v}^\dagger  = \braket{v}{u}
\end{split}
\end{equation*}
\sphinxAtStartPar
Hemos usado que \(\bra{u}^\dagger = \ket{u}\) y  \(\ket{v}^\dagger = \bra{v}\) pero le hemos añadido una regla más:
\sphinxstyleemphasis{al tomar el mapa adjunto es necesario invertir el orden de los elementos}

\sphinxAtStartPar
De no haber seguido esta regla, habríamos obtenido un resultado \sphinxstylestrong{erróneo}
\begin{equation*}
\begin{split}
\braket{u}{v}^\dagger \to \ket{u}\bra{v} 
 \end{split}
\end{equation*}
\sphinxAtStartPar
que no es ni siguiera un número complejo.

\sphinxAtStartPar



\subsubsection{Norma}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:norma}}
\sphinxAtStartPar
Una \sphinxstylestrong{norma} es un una función real \(\|\cdot\| : \Lin(\Hil) \to {\mathbb R}\) con las siguientes propiedades
\begin{itemize}
\item {} 
\sphinxAtStartPar
ser definida positiva \(\|A\|\geq 0\) con \(\| A\| = 0 \Leftrightarrow A= 0\)

\item {} 
\sphinxAtStartPar
homogeneidad \(\|\lambda A\| = |\lambda| \|A\|\)

\item {} 
\sphinxAtStartPar
triangle inequality. \(\|A+B\| \leq \| A\| + \|B\|\)

\end{itemize}

\sphinxAtStartPar
Un espacio de Hilbert es, automáticamente un espacio normado.
La positividad  del producto escalar de un vector por sí mismo  permite definir su \sphinxstyleemphasis{norma}.
\begin{equation*}
\begin{split}
\|\ket{v}\| = \sqrt{\braket{v}{v}} 
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
En contraste con la definición de producto escalar en espacios vectoriales reales, en el caso complejo se hace necesario conjugar el bra, para  que la norma de un vector sea siempre real y positiva. Esta es la idea detrás de la definición de la conjugación adjunta.

\item {} 
\sphinxAtStartPar
El único vector que tiene norma nula en un espacio de Hilbert es el elemento neutro

\end{itemize}
\begin{equation*}
\begin{split}
\braket{v}{v} = 0 ~~~ \Leftrightarrow ~~~\ket{v} = 0
\end{split}
\end{equation*}\end{sphinxadmonition}


\subsubsection{Distancia}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:distancia}}
\sphinxAtStartPar
Dados dos elementos \(\ket{u}\) y \(\ket{v}\) de \(\Hil\), podemos definir la \sphinxstyleemphasis{distancia} entre ellos como la \sphinxstyleemphasis{norma de su diferencia}
\begin{equation*}
\begin{split}
d(\rule{0mm}{5mm}\ket{v},\ket{w}) = \| \ket{v}-\ket{w}\|
\end{split}
\end{equation*}
\sphinxAtStartPar
En particular
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(d(\ket{v}, \ket{w}) = d(\ket{w}, \ket{v})\)

\item {} 
\sphinxAtStartPar
\(d(\ket{v}, \ket{v}) = 0\)

\end{itemize}


\subsection{Base ortonormales}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:base-ortonormales}}
\sphinxAtStartPar
Hasta ahora, a los vectores de una base \(\{\ket{e_i}\}\) sólo se les ha pedido que sean \(N\) vectores \sphinxstyleemphasis{linealmente independientes}, donde \(N\) es la dimensión del espacio vectorial \(\V\):

\sphinxAtStartPar
En un espacio de Hilbert \(\Hil\) tiene sentido calcular el producto escalar de dos elementos de una base.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Una base ortornormal se caracteriza por la siguiente lista de productos escalares
\begin{equation*}
\begin{split}
\braket{e_i}{e_j} = \delta_{ij}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
Por un lado, dos elementos distintos de la base son ortogonales \(\braket{e_1}{e_2} = 0\).

\item {} 
\sphinxAtStartPar
Por otro, todos están normalizados  \( \| e_i \| = \sqrt{\braket{e_1}{e_1}} = \sqrt{1} = 1\).

\end{itemize}

\sphinxAtStartPar
En este curso siempre supondremos que las bases con las que trabajamos son ortonormales. Ello se justifica en base al siguiente teorema:

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema: Teorema de Gram\sphinxhyphen{}Schmidt

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Dada una base general \(\{\braket{f_i}{f_j}\neq \delta_{ij}\}\) de vectores no ortonormales, existe una procedimiento iterativo (de Gram\sphinxhyphen{}Schmidt ) para construir, a partir de ella, una nueva base ortonormal \(\{\braket{e_i}{e_j}\}=\delta_{ij}\).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Dado un vector  \(\ket{v} = \sum_{i=1}^N v_i \ket{e_i}\) escrito en una base ortonormal, la \sphinxstyleemphasis{componente} \(v_i\) se extrae mediante la \sphinxstyleemphasis{proyección ortogonal}
\begin{equation*}
\begin{split}
v_i =\braket{e_i}{v}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Verifica esta expresión
\end{sphinxadmonition}
\subsubsection*{Solución}
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_02_Vectores_myst:20254dbe-7e30-42f8-a865-08fa177745b9}\begin{eqnarray}
\braket{e_k}{v} &=&  \bra{e_k}\left(\sum_{j=1}^N v_j\ket{e_j}\right) \nonumber\\
                &=&  \sum_{j=1}^N  v_j\braket{e_k}{e_j}  \nonumber\\
                &=&  \sum_{j=1}^N  v_j\delta_{kj} = v_k
\end{eqnarray}
\sphinxAtStartPar
En una base ortonormal, calcular el valor de un \sphinxstyleemphasis{producto escalar} \(a=\braket{u}{v}\) es muy simple

\begin{eqnarray*}
a = 
\braket{u}{v}&=& \left(\sum_{i}u_i^*\bra{e_i}\right)\left(\sum_{j}v_j\ket{e_j} \right) = 
\sum_{ij} u_i^* v_j  \braket{e_i}{e_j}
=
\sum_{ij} u_i^* v_j \delta_{ij} 
\\
&=&\sum_{i} u_i^* v_i =
  \begin{pmatrix}
{u_1^*} & {u_2^*} & \cdots & {u_N^*}
\end{pmatrix}\begin{pmatrix} {v_1}\\ {v_2}\\ \vdots \\ {v_N} 
\end{pmatrix}
\end{eqnarray*}

\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
La expresión de la izquierda  \(a = \braket{u}{v}\) no hace referencia a ninguna base. Por tanto, el resultado \(\sum_{i=1}^n{ u_i^* v_i} \) debe ser independiente de la base que utilizamos para representar estos vectores mediante sus componentes \(u_i\) y \(v_i\).

\sphinxAtStartPar
Subrayamos la importancia de esto: \(\braket{u}{v}\) puede ser calculado en la base más conveniente.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio (Explícaselo a tu ordenador) }
\begin{itemize}
\item {} 
\sphinxAtStartPar
Escribe una función \(braket(u,v)\) que calcule y devuelva la el producto escalar \(\braket{u}{v}\), y, con ella, una función \(norm(u)\) que calcule la norma \(\| \ket{u}\|\).
Verifica que \(\| \ket{u}\| = \sqrt{\braket{u}{u}}\) coincide con el resultado que da la función \(np.linalg.norm\).

\item {} 
\sphinxAtStartPar
Escribe una función \(random\_ket\) que genere un vector normalizado  \(\ket{v}\in\Hil\) de dimensión \(d\).

\sphinxAtStartPar
Añade ambas funciones al archivo macrotQ.py

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{uket} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{random\PYGZus{}ket}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{vket} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{random\PYGZus{}ket}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}


\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{braket}\PYG{p}{(}\PYG{n}{uket}\PYG{p}{,}\PYG{n}{vket}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
(0.7254644130171193+0.24753624258665705j)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Descomposición ortogonal}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_02_Vectores_myst:descomposicion-ortogonal}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Decimos que \(\Hil\) admite una suma directa ortogonal \(\Hil = \Hil_1 \oplus \Hil_2\) cuando todo vector \(\ket{u}\in \Hil\) se puede escribir en la forma
\begin{equation*}
\begin{split}
\ket{u} = \ket{u_1} + \ket{u_2} 
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(\ket{u_1}\in \Hil_1\), \(\ket{u_2}\in \Hil_2\) y \(\braket{u_1}{u_2} = 0\).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Dada una elección de  \(\ket{u_1}\) el vector \(\ket{u_2}\) es único.

\sphinxAtStartPar
Este resultado no se refiere a un espacio vectorial \(\Hil\) de dimensión 2. Cada línea en la figura anterior representa  un subespacio vectorial \(\ket{u_1} \in \Hil_1\) y \(\ket{u_2}\in \Hil_2\).

\sphinxAtStartPar
De modo que,  lo que el teorema afirma es que hay infinitas descomposiciones de la forma \(\Hil = \Hil_1\oplus \Hil_2\) donde las dimensiones se suman.
\begin{equation*}
\begin{split}
\hbox{dim}\,\Hil = \hbox{dim}\,\Hil_1  + \hbox{dim}\,\Hil_2  
\end{split}
\end{equation*}
\sphinxAtStartPar
La anterior expresión define lo que se conoce como \sphinxstyleemphasis{suma directa} de espacios vectoriales. En particular, de una suma directa \sphinxstyleemphasis{ortogonal}

\sphinxstepscope
\begin{quote}

\sphinxAtStartPar
Feb 13, 2024 | 19 min read
\end{quote}


\begin{wrapfigure}{r}{0.150\linewidth}
\centering
\noindent\sphinxincludegraphics[width=0.150\linewidth]{{Logo_TalentQ_Azul}.png}
\end{wrapfigure}


\section{Operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operadores}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst::doc}}
\sphinxAtStartPar

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ../../macro\PYGZus{}tQ.py
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{macro\PYGZus{}tQ} \PYG{k}{as} \PYG{n+nn}{tQ}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k}{as} \PYG{n+nn}{la}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,}\PYG{n}{Markdown}\PYG{p}{,}\PYG{n}{Latex}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{array\PYGZus{}to\PYGZus{}latex}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,} \PYG{n}{Latex}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Operadores y Matrices}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operadores-y-matrices}}
\sphinxAtStartPar
En un espacio vectorial, además de los vectores, será esencial entender la manera en que estos se pueden transformar entre sí,

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: Operador lineal

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Un operador lineal es una aplicación \(A:\Hil \to \Hil\)  que transforma un vector  en otro
\begin{equation*}
\begin{split}
A: \ket{u} ~~\to ~~ \ket{v}   
\end{split}
\end{equation*}
\sphinxAtStartPar
de forma lineal.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
La linealidad se refiere a la siguiente propiedad:
\begin{equation*}
\begin{split}
A: (\alpha\ket{u} + \beta\ket{w})~~\to ~~ \ket{v} =\alpha A\ket{u} + \beta A\ket{w}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Nota (Sobre la notación) }

\sphinxAtStartPar
Escribimos también \(\ket{v} = A\ket{u} \equiv \ket{Au}\) \(~~\)(donde \(Au\) debe entenderse como una etiqueta)
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejemplo}

\sphinxAtStartPar
Un operador  fácil de visualizar es el operador de rotación en un plano. Dado un ángulo \(\theta \in (0,2\pi)\) el operador \(A = R(\theta)\) gira cualquier vector un ángulo \(\theta\) en el sentido antihorario

\sphinxAtStartPar
Un vector en el plano \({\bf u} =  (u_1,u_2)\)  es equivalente al número complejo \(u = u_1 + i u_2\) en el plano complejo \(V = {\mathbb C}\).

\sphinxAtStartPar
Escrito en polares, \(u=|u|e^{i\phi}\), y sabemos que una rotación de ángulo \(\theta\) es equivalente a añadirle dicho  ángulo a la fase
\begin{equation*}
\begin{split}
 v = R(\theta) u = |u| e^{i(\phi + \theta)} =  |u| e^{i\phi } e^{i\theta} = u\cdot e^{i\theta} 
\end{split}
\end{equation*}
\sphinxAtStartPar
Por tanto, para rotar un número complejo un ángulo \(\theta\) basta con multiplicarlo por la fase \(e^{i\theta}\), que se corresponde con el operador \(R(\theta)\) en el espacio vectorial \(V = \mathbb{C}\).

\sphinxAtStartPar
La propiedad fundamental de una rotación es la de mantener invariante el módulo  \(|v| = |u|\).
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Usando el ejemplo anterior, define una función \(R\), que recibe un vector en el plano \((u_1,u_2)\) y devuelve el vector \((v_1,v_2)\) de componentes rotadas un ángulo \(\theta\).
\subsubsection*{Solución}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
def R(u1,u2,theta):
    u = u1 + u2*1j
    v = u*np.exp(1j*theta) \PYGZsh{} u rotado un angulo theta
    return v.real,v.imag    
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}ángulo que queremos rotar\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{theta}\PYG{o}{=}\PYG{l+m+mf}{0.6} 

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}vector a rotar\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{u1}\PYG{o}{=}\PYG{l+m+mf}{2.}
\PYG{n}{u2}\PYG{o}{=}\PYG{l+m+mf}{2.}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}v1 y v2 a partir de u1, u2 y theta\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{k}{def} \PYG{n+nf}{R}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{theta}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{u} \PYG{o}{=} \PYG{n}{u1} \PYG{o}{+} \PYG{n}{u2}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}
        \PYG{n}{v} \PYG{o}{=} \PYG{n}{u}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{theta}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} u rotado un angulo theta}
        \PYG{k}{return} \PYG{n}{v}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{n}{v}\PYG{o}{.}\PYG{n}{imag}
    
\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2} \PYG{o}{=}  \PYG{n}{R}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u2}\PYG{p}{,}\PYG{n}{theta}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Representación en el plano complejo \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{v1}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{o}{+}\PYG{n}{v2}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{plot\PYGZus{}2D\PYGZus{}plane}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{right}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{up}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb}{abs}\PYG{p}{(}\PYG{n}{v2}\PYG{p}{)}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{u1}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{draw\PYGZus{}vector}\PYG{p}{(}\PYG{n}{v1}\PYG{p}{,}\PYG{n}{v2}\PYG{p}{,}\PYG{n}{vcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{cd297fda04d3b99738e38d9cc385645f2e3eff14abbbc2c5804bd9bf023b166e}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Matriz de un operador}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:matriz-de-un-operador}}
\sphinxAtStartPar


\sphinxAtStartPar
\sphinxstyleemphasis{Dada una base} \(\ket{i}\)

\sphinxAtStartPar
\(\Rightarrow \)  un vector queda especificado por una \sphinxstyleemphasis{columna de  componentes}
\begin{equation*}
\begin{split}
\ket{v} \sim \begin{pmatrix} v_1 \\ v_2\\ \vdots \\ v_N\end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
\(\Rightarrow \)  un operador queda definido por una \sphinxstyleemphasis{matriz de componentes}.
\begin{equation*}
\begin{split}
A \sim \begin{pmatrix} 
A_{11} & A_{12} & \cdots & A_{1N} \\
A_{21} & A_{22} & \cdots & A_{2N} \\
\vdots & \vdots &  \ddots      & \vdots \\
A_{N1} & A_{N2} &    \cdots    & A_{NN}
\end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
Efectivamente, en una base, la relación \(\ket{v} = A\ket{u}\) equivale a una ecuación que relacione las componentes de ambos vectores
\begin{equation*}
\begin{split}
v_i = \sum_{j=1}^N A_{ij} u_j  \, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Esta operación se corresponde con la siguiente composición de matrices
\begin{equation*}
\begin{split}
\begin{pmatrix}
v_1 \\ v_2 \\ \vdots \\ v_N \end{pmatrix} =  \begin{pmatrix} 
A_{11} & A_{12} & \cdots & A_{1N} \\
A_{21} & A_{22} & \cdots & A_{2N} \\
\vdots & \vdots &  \ddots      & \vdots \\
A_{N1} & A_{N2} &    \cdots    & A_{NN}
\end{pmatrix}
 \begin{pmatrix} 
u_1 \\ u_2 \\ \vdots \\ u_N\end{pmatrix}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejemplo}

\sphinxAtStartPar
Continuando con el ejemplo del operador de rotación en un plano, hemos visto que las componentes de \(u = u_1 + i u_2\) y las de \(R(\theta)u = v = v_1 + i v_2\) se obtienen mediante la multiplicación por una fase pura
\begin{eqnarray*}
v&=& u e^{i\theta} \\
\end{eqnarray*}
\sphinxAtStartPar
Vamos a desarrollar cada miembro en cartesianas, separando las partes real e imaginaria
\begin{eqnarray*}
v_1 + i v_2 &=& (u_1 + iu_2) (\cos \theta + i \sin \theta)  \\
    \rule{0mm}{6mm}
    &=& (\cos\theta \, u_1 - \sin \theta\,  u_2) + i(\sin\theta\,  u_1 + \cos \theta\,  u_2)
\end{eqnarray*}
\sphinxAtStartPar
es decir las coordenadas del vector origen y el vector rotado imagen se relacionan en la  forma
\begin{eqnarray*}
v_1 = \cos\theta \, u_1 - \sin \theta\,  u_2 ~~~~~~~,~~~~~~~~
v_2 = \sin\theta \, u_1 + \cos \theta\,  u_2     
\end{eqnarray*}
\sphinxAtStartPar
que podemos expresar en forma matricial
\begin{equation*}
\begin{split}
\begin{pmatrix} v_1 \\ v_2 \end{pmatrix} = \begin{pmatrix} \cos\theta & -\sin\theta \\ \sin\theta &\cos\theta\end{pmatrix} \begin{pmatrix} u_1 \\ u_2 \end{pmatrix}
\end{split}
\end{equation*}\end{sphinxadmonition}


\subsection{Base de Operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:base-de-operadores}}

\subsubsection{Producto externo}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:producto-externo}}
\sphinxAtStartPar


\sphinxAtStartPar
Dependiendo del orden en que los compongamos, \(~\braket{u}{v}~\) ó \(~\ketbra{v}{u}~\), el resultado es  muy distinto
\begin{itemize}
\item {} 
\sphinxAtStartPar
El \sphinxstylestrong{producto interno}, o \sphinxstyleemphasis{producto escalar} es un \sphinxstyleemphasis{número complejo}

\end{itemize}
\begin{equation*}
\begin{split}
 a = \braket{u}{v} = \braket{v}{u}^* 
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El \sphinxstylestrong{producto externo}  es un \sphinxstyleemphasis{operador}

\end{itemize}
\begin{equation*}
\begin{split}
A = \ketbra{v}{u}
\end{split}
\end{equation*}
\sphinxAtStartPar
Para comprender por qué es un operador, observamos que dicha expresión aplicada a un vector \(\ket{w}\) da otro,
\begin{equation*}
\begin{split}
A : \ket{w} ~\to ~ A\ket{w} =  \ket{v}\braket{u}{w}=\ket{v} b  = b \ket{v} 
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
El orden en que escribimos las cosas es muy relevante.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(\braket{u}{v}\) y \(\ketbra{v}{u}\) son objetos  radicalmente distintos: el primero es un número y el segundo es un operador.

\item {} 
\sphinxAtStartPar
En cambio \(\ket{v} b  = b \ket{v}\), así como \(\bra{u}b = b\bra{u}\), es decir,  los números complejos y los \(kets\) o \(bras\) pueden escribirse en cualquier orden (decimos que conmutan).

\end{itemize}

\item {} 
\sphinxAtStartPar
La acción del operador  \(A = \ket{v}\bra{u}\) es muy fácil de expresar con palabras:
\begin{itemize}
\item {} 
\sphinxAtStartPar
el operador \(A\) toma cualquier vector \(\ket{w}\) y lo convierte en un vector paralelo a \(\ket{v}\) proporcionalmente a su proyección \(b=\braket{u}{w}\).

\item {} 
\sphinxAtStartPar
si la proyección es nula \(b=0\), el operador aniquila, es decir, da el elemento neutro.

\end{itemize}

\end{enumerate}
\end{sphinxadmonition}


\paragraph{Producto externo en componentes}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:producto-externo-en-componentes}}
\sphinxAtStartPar
La diferencia entre el \sphinxstyleemphasis{producto interno} \(a=\braket{u}{v}\) y el \sphinxstyleemphasis{externo} \(A=\ketbra{u}{v}\) tiene su reflejo en una base expresando ambos vectores, \(\ket{u} = \sum_i u_i\ket{i}\) y \(\ket{v} = \sum_j v_j \ket{j}\),  en componentes en una base ortonormal
\begin{itemize}
\item {} 
\sphinxAtStartPar
el \sphinxstyleemphasis{número complejo} \(a\)  es el \sphinxstyleemphasis{producto escalar}

\end{itemize}
\begin{equation*}
\begin{split}
 a = \braket{u}{v}  = \begin{pmatrix} u_1^*,...,u_N^*\end{pmatrix}
\begin{pmatrix} v_1 \\ \vdots \\ v_N\end{pmatrix}\, =  \sum_i u_i^*v_i
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
la matriz \(A_{ij}\)    \sphinxstyleemphasis{representa} el operador \(A\) en la base \(\{\ket{i}=\ket{e_i}\}\)

\end{itemize}
\begin{equation*}
\begin{split}
A = \ketbra{v}{u} ~\sim ~\begin{pmatrix} v_1 \\ \vdots \\ v_N\end{pmatrix}
\begin{pmatrix} u_1^*,...,u_N^*\end{pmatrix} ~=~ 
\begin{pmatrix} v_1 u_1^* & v_1u_2^* & ... & v_1 u_N^* \\
v_2 u_1^* & v_2 u_1^*& ... & v_2 u_N^* \\ \vdots & \vdots  & \ddots & \vdots \\
v_N u_1^* & & ... & v_N u_N^* \end{pmatrix} ~ = ~A_{ij}
\end{split}
\end{equation*}

\subsubsection{Base canónica de operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:base-canonica-de-operadores}}
\sphinxAtStartPar


\sphinxAtStartPar
Consideremos el \sphinxstyleemphasis{producto externo} de dos elementos de la base ortonormal
\(\ketbra{i}{j}\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
La acción de \(\ketbra{i}{j}\) sobre otro vector, \(\ket{k}\),  de la base es sencilla

\end{itemize}
\begin{equation*}
\begin{split}
 \ket{i}\braket{j}{k} = \ket{i} \delta_{jk} = \left\{ \begin{array}{rl}
0 & {\rm si} ~~k\neq j \\ \ket{i} & {\rm si} ~~ k=j \end{array} \right.
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
La matriz asociada al operador  tiene sólo un 1 en el elemento \((ij)\) y cero en todos los demás. Por ejemplo, supongamos que
\(N=4\)

\end{itemize}
\begin{equation*}
\begin{split}
\ketbra{2}{3} ~\to ~~
 \begin{pmatrix} 0 \\ 1 \\ 0 \\ 0 \end{pmatrix}\begin{pmatrix} 0 & 0 & 1 & 0 \end{pmatrix} = 
\begin{pmatrix}
0 &  0 & 0 &  0 \\  0 &  0 & 1&  0 \\ 0 &  0 & 0 &  0 \\ 0 &  0 & 0 &  0
\end{pmatrix} ~~\Rightarrow ~~ A_{ij} = \delta_{i2}\delta_{j3}
\end{split}
\end{equation*}
\sphinxAtStartPar
Los elementos de matriz \(A_{ij}\) expresan las componentes de un operador en la base de operadores \(\ketbra{i}{j}\)
\begin{equation*}
\begin{split}
A ~=~ \sum_{i,j=1}^N A_{ij} \ketbra{i}{j} 
\end{split}
\end{equation*}\subsubsection*{Consistencia}

\sphinxAtStartPar
Verifiquemos que actúa de la forma correcta
\begin{equation*}
\begin{split}
\begin{array}{rcl}
A |u\rangle &=&  \sum_{i,j} A_{ij} \ketbra{i}{j}  \left(\sum_k u_k |k\rangle \right) \\
&\stackrel{\rm linealidad}{=} \rule{0mm}{6mm}& \sum_{i,j} \sum_k A_{ij} | i\rangle  \,   u_k \langle j| k\rangle \nonumber\\
&\stackrel{\rm ortonormalidad}{=}\rule{0mm}{6mm}& \sum_{i,j,k} A_{ij} | i\rangle  \,   u_k \delta_{jk}\\
&=\rule{0mm}{6mm}&\sum_{ij} A_{ij}\,|i\rangle \, u_j= \sum_i \left(\sum_{j} A_{ij}\, u_j\right)  |i\rangle    \\
&=\rule{0mm}{6mm}&\sum_i v_i \ket{i} \nonumber\\
&=\rule{0mm}{6mm}&   | v\rangle
\end{array}
\end{split}
\end{equation*}

\paragraph{Elementos de matriz}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:elementos-de-matriz}}
\sphinxAtStartPar
De la misma manera que obteníamos las componentes de un vector proyectando sobre un elemento de la base
\begin{equation*}
\begin{split}
v_i = \braket{i}{v}
\end{split}
\end{equation*}
\sphinxAtStartPar
ahora podemos obtener los \sphinxstyleemphasis{elementos de matriz} de un operador \(A\) en la forma
\begin{equation*}
\begin{split}  A_{ij} = \bra{i} A \ket{j} \end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Comprueba la consistencia de las expresiones \(~A = \sum_{i,j=1}^N A_{ij} \ketbra{i}{j} \) y \(~A_{ij} = \bra{i} A \ket{j}\)
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Resumen}

\sphinxAtStartPar
Dada una base \(\{\ket{i}\}\) podemos expresar un operador mediante una matriz \(A_{ij}\). La relación concreta es
\begin{itemize}
\item {} 
\sphinxAtStartPar
como operador \(\to ~ A = \sum_{ij} A_{ij}\ketbra{i}{j}\)

\item {} 
\sphinxAtStartPar
como elemento de matriz \(\to ~ A_{ij} = \bra{i}A\ket{j}\)

\end{itemize}
\end{sphinxadmonition}


\paragraph{Cambio de base}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:cambio-de-base}}
\sphinxAtStartPar
Dos bases ortonormales \(\ket{e_i}\) y \(\ket{\tilde e_i}\) se relacionadas linealmente mediante una matriz
\begin{equation*}
\begin{split} \ket{e_j} \to \ket{\tilde e_j} = \sum_{ij}U_{ij} \ket{e_i}\end{split}
\end{equation*}
\sphinxAtStartPar
La relación \sphinxstyleemphasis{adjunta} es muy sencilla de obtener
\begin{equation*}
\begin{split} \bra{e_j} \to \bra{\tilde e_j} = \sum_{ij}U^*_{ij} \bra{e_i}\end{split}
\end{equation*}
\sphinxAtStartPar
En cada base, un operador \(A\) \sphinxstyleemphasis{se representa} mediante elementos de matriz distintos
\begin{equation*}
\begin{split}
 A_{ij} = \bra{e_i} A \ket{e_j} ~~~~,~~~~~ \tilde A_{ij} = \bra{\tilde e_i} A \ket{\tilde e_j} \, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Podemo encontrar la relación sustituyendo el cambio de base
\begin{eqnarray*}
\tilde A_{ij} &=& \bra{\tilde e_i} A \ket{\tilde e_j} \\ \rule{0mm}{8mm}
&=& \sum_{k}U^*_{ki}\bra{e_k} ~A~ \sum_l U_{lj}\ket{e_l} \\ 
&=&  \sum_{k,l} U^\dagger_{ik}\bra{e_k} A  \ket{e_l}U_{lj}   = \sum_{k,l} U^\dagger_{ik}A_{kl} U_{lj} \, .
\end{eqnarray*}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Lema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Bajo un cambio de bases ortonormales \( \ket{e_j} \to \ket{\tilde e_j} = \sum_{i}U_{ij} \ket{e_i}\) las componentes de un vector \(\ket{v}\) y de  un operador \(A\) cambian siguiendo la regla:
\begin{eqnarray*}
\tilde v_i &=& (U^\dagger \cdot v)_i \\ \rule{0mm}{12mm}
\tilde A_{ij} &=& (U^\dagger \cdot A \cdot U)_{ij}
\end{eqnarray*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
La regla mnemotécnica es que las columnas se multiplican por \(U^\dagger\cdot\) y las filas por \(\cdot\, U\)
\begin{equation*}
\begin{split}
\begin{pmatrix} \tilde v_1 \\ \vdots \\ \tilde v_N \end{pmatrix} = 
U^\dagger \cdot \begin{pmatrix} v_1 \\ \vdots \\  v_N \end{pmatrix} ~~~~
~~~~~~~;~~~~~~~~
\begin{pmatrix} 
\tilde A_{11} & \cdots & \tilde A_{1N} \\
\tilde \vdots & \ddots & \vdots  \\
\tilde A_{N1} & \cdots & \tilde A_{NN} 
\end{pmatrix} 
 =  U^\dagger\cdot
 \overbrace{\begin{pmatrix} 
 A_{11} & \cdots &  A_{1N} \\
\tilde \vdots & \ddots & \vdots  \\
 A_{N1} & \cdots &  A_{NN} 
\end{pmatrix} }^{\large \cdot ~ U}
\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe una función \(basis\_change\) que reciba una matriz \(U_{ij}\) de cambio de base \(\ket{\tilde e_j} = \sum_i{U_{ij}}\ket{e_i}\), la componentes \(v_i\) de un vector, ó \(A_{ij}\) de un operador, y devuelva las componentes \(\tilde v_i~\) ó \(~\tilde A_{ij}\) en la nueva base.

\sphinxAtStartPar
La matriz \(\begin{pmatrix} 0 & -i \\ i & 0\end{pmatrix}\) representa un operador \(\sigma_y\) en la base \(\{\ket{0},\ket{1}\}\). Escribe \(\sigma_y\) en la base \(\{\ket{\!+\!i}= \frac{1}{\sqrt{2}}(\ket{0}+i \ket{1}),\ket{\!-\!i}= \frac{1}{\sqrt{2}}(\ket{0}-i \ket{1})\}\)
\end{sphinxadmonition}


\paragraph{Relación de completitud}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:relacion-de-completitud}}
\sphinxAtStartPar
La acción del operador identidad es
\begin{equation*}
\begin{split}
I\ket{v} = \ket{v}
\end{split}
\end{equation*}
\sphinxAtStartPar
En particular sobre todo elemento de la base \(I\ket{i} = \ket{i}\). En otras palabras,
el operador identidad \(I\) tiene por matriz \(I_{ij}=\delta_{ij}={\rm diagonal}\, (1,1,...,1)\) con lo que
\begin{equation*}
\begin{split}
I = \sum_{i}  \ketbra{i}{i}= \sum_{ij} \delta_{ij}\ketbra{i}{j} 
\end{split}
\end{equation*}
\sphinxAtStartPar
Esta expresión se conoce también como relación de completitud o, también, relación de cierre y se utiliza muy frecuentemente.

\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
La relación de completitud es, en realidad, una propiedad de   cualquier base. Dicho de otro modo, si \(\{\ket{e_i}\}\) y \(\{\ket{\tilde e_i}\}\) son, ambas, bases entonces \(I\ket{e_i} = \ket{e_ i}\) y \(I\ket{\tilde e_j} = \ket{\tilde e_j}\), entonces \(+1\) es el único autovalor de \(I\) en cualquier base, y la descomposición espectral da
\begin{equation*}
\begin{split}
I =  \sum_{i}  \ketbra{e_i}{e_i} =  \sum_{j}  \ketbra{\tilde e_j}{ \tilde e_j}\, .
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
La relación de cierre, o completitud,  siempre \sphinxstylestrong{se puede insertar} en cualquier momento del cálculo. Se utiliza con frecuencia para efectuar cambios de base.
\$\(
\ket{u}  =  \sum_i u_i  I \ket{e_i} =  \sum_i   u_i \left(\sum_j\ketbra{\tilde e_j}{\tilde e_j} \right)\ket{e_i} =\sum_j \left( \sum_i \braket{\tilde e_j}{e_i} u_i \right) \ket{\tilde e_j}
= \sum_j \tilde u_j \ket{\tilde e_j}
\)\$

\sphinxAtStartPar
De aquí se sigue que
\begin{equation*}
\begin{split}
\tilde u_j  = \sum_j C_{ji} u_i 
\end{split}
\end{equation*}
\sphinxAtStartPar
donde la matriz de cambio es
\begin{equation*}
\begin{split}
C_{ji} = \braket{\tilde e_j}{e_i} 
\end{split}
\end{equation*}

\subsection{El Espacio Vectorial \protect\(\Lin(\Hil)\protect\)}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:el-espacio-vectorial-lin-hil}}
\sphinxAtStartPar
El conjunto de \sphinxstylestrong{todos} los operadores lineales sobre un espacio vectorial \(\Hil\) tiene, de forma natural, una estructura de espacio vectorial que denominamos \(\Lin(\Hil)\)

\sphinxAtStartPar
En efecto, dados dos operadores,  \(A\) y \(B\) tanto la suma \(C = A+B\) como la multiplicación por un número complejo \(D=\lambda A\) son \sphinxstyleemphasis{nuevos operadores} definidos por su acción sobre un vector cualquiera \(\ket{v}\in \Hil\)
\begin{equation*}
\begin{split}
C\ket{v} ~=~ (A + B) \ket{v} = A\ket{v} + B\ket{v}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
D\ket{v} ~=~ (\lambda A) \ket{v} = \lambda (A\ket{v})
\end{split}
\end{equation*}

\subsubsection{Operador Adjunto}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operador-adjunto}}
\sphinxAtStartPar


\sphinxAtStartPar
La conjugación \sphinxstyleemphasis{adjunta} se puede extender a \({\rm Lin}(\Hil)\)
\begin{equation*}
\begin{split}
\dagger ~\to ~
\left\{
\begin{matrix}
z & \leftrightarrow  &  z^* \\
|u\rangle & \leftrightarrow &   \langle u | \\
A & \leftrightarrow & A^{\dagger}
\end{matrix}
\right.
\end{split}
\end{equation*}
\sphinxAtStartPar
y hay dos reglas más que permiten aplicar \(\dagger\) a sumas y productos de  objetos  \(a \in\{z,\ket{u},A\}\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{linealidad} \(( a + b)^\dagger = a^\dagger + b^\dagger \)

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{trasposición} \((ab)^\dagger = b^\dagger a^\dagger\) (sólo relevante cuando \(a\) y \(b\) no conmuten)

\end{itemize}

\begin{sphinxadmonition}{note}{Ejemplos}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\(\ket{v} = A\ket{u} ~~~~\Leftrightarrow ~~~~\bra{v} = \bra{u}A^\dagger
~~\) donde el operador en la derecha actúa sobre el \sphinxstyleemphasis{bra} a su izquierda. Notar que, como \(\ket{v}^\dagger=\ket{Au}^\dagger = \bra{Au}\) la ecuación anterior implica

\end{enumerate}
\begin{equation*}
\begin{split}
\bra{Au} = \bra{u} A^\dagger
\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\end{enumerate}
\begin{equation*}
\begin{split}
\bra{w}A\ket{u}^* = (\bra{w}A\ket{u})^\dagger = \bra{u}A^\dagger\ket{w}
\end{split}
\end{equation*}\end{sphinxadmonition}


\paragraph{Matriz adjunta}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:matriz-adjunta}}
\sphinxAtStartPar
Estas reglas nos permiten obtener el adjunto de un operador
\begin{equation*}
\begin{split}
A^\dagger = \sum_{ij}\left( A_{ij}\ketbra{i}{j}\right)^\dagger = \sum_{ij} \, \ketbra{j}{i}A_{ij}^* =  \sum_{ji} \, A_{ji}^*\ketbra{i}{j}
\end{split}
\end{equation*}
\sphinxAtStartPar
donde en la última ecuación hemos intercambiado los nombres \(i\leftrightarrow j\)

\sphinxAtStartPar
Vemos que la matriz que representa \(A^\dagger\) es la \sphinxstyleemphasis{matriz adjunta} de \(A_{ij}\), es decir, la traspuesta y conjugada
\begin{equation*}
\begin{split}
(A^\dagger)_{ij} = A^*_{ji} = (A^{*}_{ij})^t \equiv (A_{ij})^\dagger
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(^\dagger\) significa el adjunto de un operador a la izquierda, y de una matriz a la derecha.

\sphinxAtStartPar
Si \(\Hil\) tiene dimensión \(N\), un \sphinxstyleemphasis{operador general} \(A\in \Lin(\Hil)\) se especifica mediante una matriz de \(N^2\) números complejos \(\Rightarrow A = A_{ij}\ket{e_i}\bra{e_j}\).

\sphinxAtStartPar
\(N^2\) números complejos equivalen a \(2N^2\) números reales.

\sphinxAtStartPar
En otras palabras: \(A\)  tiene \(N^2\) grados de libertad complejos y, por tanto, ésta es la dimension del espacio \({\rm L}(\Hil)\) es
\begin{equation*}
\begin{split} {\rm dim}_{\bf C}(\Lin(\Hil)) = N^2 ~~~ \Longleftrightarrow ~~~ {\rm dim}_{\bf R}(\Lin(\Hil)) =  2N^2
\end{split}
\end{equation*}

\subsection{Clases de operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:clases-de-operadores}}
\sphinxAtStartPar
Dentro de \(\Lin(\Hil)\) podemos definir subconjuntos de operadores que mantienen ciertas propiedades importantes. Algunos formarán subespacios vectoriales, y otros no.

\sphinxAtStartPar
Podemos definir dichas  \sphinxstylestrong{clases de operadores} pidiendo que satisfagan algúna \sphinxstyleemphasis{condición} o \sphinxstyleemphasis{restricción}.


\subsubsection{Operador Unitario}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operador-unitario}}
\sphinxAtStartPar


\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Un operador unitario \(U\) es tal que su adjunto es igual a su inverso
\begin{equation*}
\begin{split}
U^\dagger = U^{-1}  \, 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Naturalmente, esta ecuación se traduce en la misma ecuación para las matrices asociadas en \sphinxstyleemphasis{cualquier base}
\begin{equation*}
\begin{split}
(U_{ij})^\dagger = U_{ji}^* = U^{-1}_{ij}
\end{split}
\end{equation*}
\sphinxAtStartPar
Veamos ahora por qué hemos definido esta clase de operadores.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
La acción de un operador unitario conserva intacto el producto escalar de dos vectores cualesquiera.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Demostración}

\sphinxAtStartPar
Sea \(U\) un operador unitario, y \(\ket{\varphi'}=U\ket{\varphi}\) y \(\ket{\psi'} = U\ket{\psi}\)
dos vectores transformados por \(U\), entonces
\begin{equation*}
\begin{split}
\braket{\varphi'}{\psi'} = \left(\bra{\varphi}U^\dagger\right)U\ket{\psi} = \bra{\varphi} U^\dagger U \ket{\psi} = 
\braket{\varphi}{\psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
particularizando para \(\ket{\varphi} = \ket{\psi}\) tenemos que un operador unitario \sphinxstyleemphasis{conserva la norma}.
\begin{equation*}
\begin{split}
\|U \ket{\varphi}\| = \|\ket{\varphi}\|
\end{split}
\end{equation*}
\sphinxAtStartPar
En particular, conserva  la norma de cualquier vector.

\sphinxAtStartPar
Por tanto, conserva la \sphinxstyleemphasis{distancia} entre dos vectores \( d (\ket{v},\ket{w})= \| (\ket{v}-\ket{w}) \| \).

\sphinxAtStartPar
En un lenguaje más formal, se dice que un operador unitario es una \sphinxstyleemphasis{isometría}
\begin{itemize}
\item {} 
\sphinxAtStartPar
La \sphinxstyleemphasis{composición} de  operadores unitarios  \sphinxstylestrong{es} unitaria

\end{itemize}
\begin{equation*}
\begin{split}
(UV)^\dagger = V^\dagger U^\dagger = V^{-1}U^{-1} = (UV)^{-1} 
\end{split}
\end{equation*}
\sphinxAtStartPar
Matemáticamente esto quiere decir que los operadores unitarios forman un \sphinxstyleemphasis{grupo}
\begin{itemize}
\item {} 
\sphinxAtStartPar
La combinación lineal de operadores unitarios \sphinxstylestrong{no es} unitaria

\end{itemize}
\begin{equation*}
\begin{split}
 (a U+ bV)^\dagger = a^* V^\dagger+ b^* U^\dagger = a^* V^{-1}+ b^* U^{-1} \neq  (a U+ b V)^{-1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Matemáticamente esto quiere decir que los operadores unitarios \sphinxstylestrong{no forman} un \sphinxstyleemphasis{subespacio vectorial} de \(\Lin(\Hil)\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
Por tanto, los operadores unitarios no forman un subespacio vectorial dentro de \(\Lin(\Hil)\).

\end{itemize}

\sphinxAtStartPar
La estructura matemática que forman se denomina grupo: el grupo unitario \(U(d)\) actúa sobre \(\Hil\) de dimensión \(d\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
Aun así, forman una \sphinxstyleemphasis{variedad}: un conjunto continuo  que se puede parametrizar mediante una colección de parámetros, la \sphinxstyleemphasis{dimensión de la variedad}.

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Como hay una relación 1 a 1 entre un operador una matriz (en una base), esa dimensión será igual a la \sphinxstyleemphasis{dimensión del conjunto de matrices unitarias}

\end{itemize}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Resta de  \({\rm dim}_{\bf R}({\rm L}(\Hil)) =  2N^2\) el número de ecuaciones que restringen la matriz de un operador
unitario y halla así la  dimensión (real) del grupo \(U(N)\) de  operadores unitarios de dimensión \(N\).
\end{sphinxadmonition}


\paragraph{Bases ortonormales}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:bases-ortonormales}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Como caso particular, aplicando un operador unitario \(U\) a una base ortonormal \(\{\ket{e_i}\}\) obtenemos otra base ortonormal \(\{\ket{\tilde e_i}\}\)

\end{itemize}
\begin{equation*}
\begin{split}
\left. \begin{array}{c}\ket{\tilde e_i} = U\ket{e_i}\\ U^{-1} =  U^\dagger \end{array} \right\}
~~~~ \Longleftrightarrow ~~~~\braket{\tilde e_i}{\tilde e_j} = \bra{\tilde e_i}U^\dagger U\ket{\tilde e_j} = \braket{e_i}{e_j} = \delta_{ij}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Inversamente, dadas dos bases ortonormales, \(\{\ket{e_i}\}\) y \(\{\ket{\tilde e_i}\}\), el operador que las relaciona es un operador unitario

\end{itemize}
\begin{equation*}
\begin{split} 
 \begin{array}{rcl} 
U = \sum_i \ketbra{\tilde e_i}{e_i} & \Rightarrow &  U\ket{e_j} = \ket{\tilde e_j} 
 \\ \rule{0mm}{10mm}
U^\dagger = \sum_i \ketbra{e_i}{\tilde e_i}  & \Rightarrow &    U^\dagger\ket{\tilde e_j} = \ket{e_j} ~~~\Rightarrow ~~~U^\dagger = U^{-1}
 \end{array}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Un  operador ortogonal es un caso particular de operador  unitario con \sphinxstyleemphasis{elementos de matriz reales}. El operador de rotación \(R(\theta)\) que hemos estudiado al comienzo de este tema es un operador ortogonal. Es inmediato comprobar que

\end{itemize}
\begin{equation*}
\begin{split} R(\theta)^\dagger =R(\theta)^t = R(-\theta) = R(\theta)^{-1}\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{U}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{n}{J}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{J}\PYG{p}{,} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
\frac{\sqrt{2}}{2} & \frac{\sqrt{2} i}{2}  \\
 \frac{\sqrt{2} i}{2} & \frac{\sqrt{2}}{2}  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Uadj}\PYG{o}{=}\PYG{n}{U}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} getH es un método de la clase matrix que devuelve la matriz conjugada hermítica}
\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{Uadj}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
\frac{\sqrt{2}}{2} & - \frac{\sqrt{2} i}{2}  \\
 - \frac{\sqrt{2} i}{2} & \frac{\sqrt{2}}{2}  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{comprobamos que U es unitaria}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{Uadj}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
comprobamos que U es unitaria
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\begin{bmatrix}
1 & 0  \\
 0 & 1  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Operador Normal}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operador-normal}}
\sphinxAtStartPar


\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
un operador \(N\)  es normal si conmuta con su adjunto
\begin{equation*}
\begin{split}
NN^\dagger = N^\dagger N
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
La matrix \(N_{ij}\) posee una propiedad importante

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
\(N_{ij}\) es la matriz de un operador normal, \([N,N^\dagger]=0\), si y sólo si es unitariamente equivalente a una matriz diagonal. Es decir, si existe \(U\) con \(U^{-1} = U^\dagger\) tal que
\begin{equation*}
\begin{split}
N'_{ij} = (U^{\dagger}\cdot N \cdot U)_{ij} = 
\begin{bmatrix} \lambda_1 &  & &  \\ & \lambda_2 & &  \\ & & \ddots &  \\ & & & \lambda_D \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Operador Hermítico}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operador-hermitico}}
\sphinxAtStartPar


\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
un operador  \(H\) es Hermítico (o autoadjunto)  si  verifica la siguiente ecuación
\begin{equation*}
\begin{split}
H = H^\dagger 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Evidentemente, un \sphinxstyleemphasis{operador hermítico} \(~\Rightarrow ~\) es un \sphinxstyleemphasis{operador normal}, pero a la inversa no tiene por qué ser verdad.

\sphinxAtStartPar
La \sphinxstyleemphasis{combinación lineal} de operadores \sphinxstyleemphasis{hermíticos}  con coeficientes \sphinxstyleemphasis{reales} \sphinxstylestrong{es}  \sphinxstyleemphasis{hermítica}
\begin{equation*}
\begin{split}
C^\dagger = (a A + b B)^\dagger = a^* A^\dagger + b^* B^\dagger = aA + b B = C
\end{split}
\end{equation*}
\sphinxAtStartPar
Matemáticamente: los operadores autoadjuntos forman un subespacio vectorial real \(\hbox{Her}(\Hil) \subset \Lin(\Hil)\).

\sphinxAtStartPar
La composición de operadores hermíticos, en general \sphinxstylestrong{no es} hermítica
\begin{equation*}
\begin{split}
(A B)^\dagger = B^\dagger A^\dagger = BA \neq AB
\end{split}
\end{equation*}
\sphinxAtStartPar
Matemáticamente, no forman grupo salvo que \(A\) y \(B\) conmuten entre sí, en cuyo caso forman un \sphinxstyleemphasis{grupo Abeliano}

\sphinxAtStartPar
La matriz asociada a un operador hermítico también se llama hermítica, y coincide con su traspuesta y conjugada
\begin{equation*}
\begin{split}
A_{ij} = A^\dagger_{ij} \equiv  A^{*t}_{ij} = A^*_{ji}   
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
A partir de cualquier operador \(C\neq C^\dagger \) siempre podemos construir un operador hermítico \(H=H^\dagger\) mediante la combinación lineal
\begin{equation*}
\begin{split}
H = C + C^\dagger
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(a\) es un número real. Esto se extiende trivialmente a las matrices que los representan en cualquier base
\begin{equation*}
\begin{split}
H_{ij} = C_{ij} + C_{ji}^*
\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Resta de  \({\rm dim}_{\bf R}({\rm L}(\Hil)) =  2N^2\) el número de ecuaciones que restringen la matriz de un operador
hermítico y halla así la dimensión (real) de la  subespacio vectorial de operadores hermíticos.
\end{sphinxadmonition}

\sphinxAtStartPar
Si has hecho los dos últimos ejercicios  habrás encontrado la misma respuesta en ambos. Eso quiere decir que podría haber una relación entre matrices hermíticas y unitarias.


\subsubsection{Operador semi\sphinxhyphen{}definido positivo}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operador-semi-definido-positivo}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Decimos que un operador  \(A\) es semi\sphinxhyphen{}definido positivo  (o, no\sphinxhyphen{}negativo)  si  verifica que
\begin{equation*}
\begin{split}
\bra{u} A\ket{u} \geq 0 
\end{split}
\end{equation*}
\sphinxAtStartPar
para todo \(\ket{u}\in \Hil\).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
En este caso se dice que \(A\geq 0\). Si la desigualdad es estricta \(\bra{u} A\ket{u} \geq 0 \, \forall \ket{u}\), decimos que \(A\) es un \sphinxstyleemphasis{operador positivo}, \(A>0\).

\sphinxAtStartPar
El siguiente teorema es el equivalente al hecho de que un número real \(a\in {\mathbb R}\) admite una raíz si y solo si es no\sphinxhyphen{}negativo.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Un \(A\) hermítico, es semi\sphinxhyphen{}definido positivo    exite otro operador \(B\) tal que
\begin{equation*}
\begin{split}   
A = B^\dagger B
\end{split}
\end{equation*}
\sphinxAtStartPar
para todo \(\ket{u}\in \Hil\).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar



\subsubsection{Proyectores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:proyectores}}
\sphinxAtStartPar
El operador \(P = \ketbra{u}{u}\) \sphinxstyleemphasis{proyecta} cualquier vector en la dirección de \(\ket{u}\)
\begin{equation*}
\begin{split}
P \ket{w} = \ket{u}\braket{u}{w} = a \ket{u}
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(a = \braket{u}{w}\) es la \sphinxstyleemphasis{proyección}

\sphinxAtStartPar
De su forma se siguen dos propiedades que caracterizan un operador de proyección
\begin{itemize}
\item {} 
\sphinxAtStartPar
es hermítico

\end{itemize}
\begin{equation*}
\begin{split}
P^\dagger = \ketbra{u}{u} = P
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
es idempotente

\end{itemize}
\begin{equation*}
\begin{split}
P^2 = \ket{u}\braket{u}{u}\bra{u} = \ketbra{u}{u} = P
\end{split}
\end{equation*}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Un proyector es un operador hermítico que verifica la ecuación
\begin{equation*}
\begin{split}
P^2 = P
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}


\begin{sphinxadmonition}{note}{Notar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(P^2 = P = P^\dagger = P^{-1}\)

\item {} 
\sphinxAtStartPar
El proyector es un operador no\sphinxhyphen{}unitario: en general, la proyección reduce la norma

\end{itemize}
\begin{equation*}
\begin{split}
\| P\ket{w}\|^2 = \bra{w}P^\dagger P\ket{w} = \bra{w} P\ket{w}= \braket{w}{u}\braket{u}{w} = |\braket{u}{w}|^2 < \|\ket{u}\|\|\ket{w}\| = 1  
\end{split}
\end{equation*}
\sphinxAtStartPar
donde hemos aplicado la desigualdad de Cauchy Schwarz estricta si suponemos que \(\ket{u}\neq\ket{w}\).
\end{sphinxadmonition}


\paragraph{Matriz asociada a un proyector}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:matriz-asociada-a-un-proyector}}
\sphinxAtStartPar
Si \(\ket{u} = \ket{e_1}\) el operador \(P_1 = \ket{e_1}\bra{e_1}\) proyecta cualquier vector sobre su componente a lo largo de \(\ket{e_1}\).

\sphinxAtStartPar
En forma matricial
\begin{equation*}
\begin{split}
 \ket{e_1}\bra{e_1} = \begin{pmatrix} 1 & 0 & ...& 0 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \\ \vdots\\ 0 \end{pmatrix} =
 \begin{pmatrix} 1 & 0 &  \cdots & 0 \\ 0 & 0  & \cdots & 0 \\ 
 \vdots & \vdots &\vdots & \vdots  \\
 0  & 0 & \cdots & 0\end{pmatrix}
 \end{split}
\end{equation*}
\sphinxAtStartPar
de modo que
\begin{equation*}
\begin{split}
    \ket{e_1}\braket{e_1}{u} ~= ~\begin{pmatrix} 1 & 0 &  \cdots & 0 \\ 0 & 0  & \cdots & 0 \\ 
 \vdots & \vdots &\vdots & \vdots  \\
 0  & 0 & \cdots & 0\end{pmatrix} \begin{pmatrix} u_1 \\ u_2 \\ \vdots \\ u_N \end{pmatrix}
 = \begin{pmatrix} u^1 \\ 0 \\ \vdots \\ 0 \end{pmatrix} = u^1 \ket{e_1}
\end{split}
\end{equation*}
\sphinxAtStartPar
Si \(\ket{u} = \sum_i u^i\ket{e_i}\) es un vector unitario  \(\|\ket{u}\|=1\), entonces el proyector a lo largo de \(\ket{u}\) viene dado por
\begin{equation*}
\begin{split}
P(u) = \ketbra{u}{u} = \sum_{i,j} u_i u^*_j \ketbra{e_i}{e_j}
\end{split}
\end{equation*}
\sphinxAtStartPar
Es decir, le está asociada una matriz dada por \(P_{ij}=u_iu^*_j\). Es trivial verificar que
\begin{equation*}
\begin{split}
P^2_{ik} = \sum_j P_{ij}P_{jk} = \sum_j u_i u^*_j u_j u^*_k = u_i\left(\sum_j u^*_j u_j\right) u_k = u_i u_k^* = P_{ik}
\end{split}
\end{equation*}
\sphinxAtStartPar
como corresponde a un proyector.


\paragraph{Proyector ortogonal}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:proyector-ortogonal}}
\sphinxAtStartPar
Sea \(P = \ket{u}\bra{u}\) un proyector a lo largo de un vector \(\ket{u}.~\)
Entonces el operador \(\Rightarrow  P_\perp = I - P\) verifica que
\begin{itemize}
\item {} 
\sphinxAtStartPar
es proyector

\end{itemize}
\begin{equation*}
\begin{split}~~ P_\perp^2 = P_\perp \end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
es perpendicular a \(P\)

\end{itemize}
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_03_Operadores_myst:568fc552-8978-42c6-8d70-e3f2cc9cd589}\begin{eqnarray}
P_\perp P &=& (I - P) P = P - P^2 = P - P =  0 
\end{eqnarray}
\sphinxAtStartPar
Dado un vector \(\ket{u}\), podemos descomponer cualquier  otro vector \(\ket{\psi}\) en sus proyecciones paralela y perpendicular
\begin{equation*}
\begin{split}
\ket{\psi} = ( P + P_\perp) \ket{\psi} = a \ket{u} + b \ket{u_\perp} 
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(a = \braket{u}{\psi}\) y  \(b = \braket{u_\perp}{\psi}\)

\sphinxAtStartPar
La ecuación \(\ket{\psi} = a \ket{u} + b\ket{u_\perp}\) quiere decir que los tres vectores están en un mismo hiperplano

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen]{{Projectors}.png}
\end{figure}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{3}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ generate a random vector}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{u} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{random\PYGZus{}ket}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ build the parallel and perpendicular projectors}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{P\PYGZus{}par} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{ket\PYGZus{}bra}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{u}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{P\PYGZus{}perp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{identity}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{P\PYGZus{}par}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{P\PYGZus{}par}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{P\PYGZus{}perp}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
0.471010764 - 0.3033902688 i  \\
 0.239801871 + 0.4636412817 i  \\
 -0.429936505 + 0.478319591 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{bmatrix}
0.313896795 & -0.0277149906 - 0.2911335884 i & -0.347622231 - 0.0948551242 i  \\
 -0.0277149906 + 0.2911335884 i & 0.2724681755 & 0.1186691299 - 0.3140382451 i  \\
 -0.347622231 + 0.0948551242 i & 0.1186691299 + 0.3140382451 i & 0.4136350295  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{bmatrix}
0.686103205 & 0.0277149906 + 0.2911335884 i & 0.347622231 + 0.0948551242 i  \\
 0.0277149906 - 0.2911335884 i & 0.7275318245 & -0.1186691299 + 0.3140382451 i  \\
 0.347622231 - 0.0948551242 i & -0.1186691299 - 0.3140382451 i & 0.5863649705  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ check properties P\PYGZca{}2 = P, and orthogonality }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{P\PYGZus{}par}\PYG{n+nd}{@P\PYGZus{}par} \PYG{o}{\PYGZhy{}} \PYG{n}{P\PYGZus{}par}
\PYG{n}{B} \PYG{o}{=} \PYG{n}{P\PYGZus{}perp}\PYG{n+nd}{@P\PYGZus{}perp} \PYG{o}{\PYGZhy{}} \PYG{n}{P\PYGZus{}perp}
\PYG{n}{C} \PYG{o}{=} \PYG{n}{P\PYGZus{}par}\PYG{n+nd}{@P\PYGZus{}perp}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{C}\PYG{p}{)}\PYG{p}{)}


\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ obtain parallel and perpendicular components of another vector}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{random\PYGZus{}ket}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}

\PYG{n}{v\PYGZus{}par} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{P\PYGZus{}par}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
\PYG{n}{v\PYGZus{}perp} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{P\PYGZus{}perp}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ check perpendicularity}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{tQ}\PYG{o}{.}\PYG{n}{braket}\PYG{p}{(}\PYG{n}{v\PYGZus{}par}\PYG{p}{,}\PYG{n}{v\PYGZus{}perp}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
0 & 0 & 0  \\
 0 & 0 & 0  \\
 0 & 0 & 0  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}0j
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Ejercicio (reflector) }

\sphinxAtStartPar
Dado un vector unitario \(\ket{u}\), escribe
\begin{itemize}
\item {} 
\sphinxAtStartPar
el operador \(R_u^{\perp}\) que refleja la componente perpendicular a \(\ket{u}\) de cualquier  vector \(\ket{\psi}\)

\item {} 
\sphinxAtStartPar
el operador \(R_{u}^{\|}\) que refleja la componente paralela a \(\ket{u}\) de cualquier  vector \(\ket{\psi}\)

\end{itemize}
\end{sphinxadmonition}


\paragraph{Proyectores sobre un subespacio}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:proyectores-sobre-un-subespacio}}
\sphinxAtStartPar
Consideremos una base ortonormal \(\{\ket{e_i}\}~,i=1,...,N \)  de \(\Hil\) y dividámosla en dos subconjuntos
\begin{equation*}
\begin{split}
\{\ket{e_i}\},~ i=1,...,N_1 ~~~~~~~,~~~~~~~~\{\ket{e_{j+N_1}},~j=1,...,N_2   
\end{split}
\end{equation*}
\sphinxAtStartPar
Cualquier vector admite una descomposición ortogonal
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_03_Operadores_myst:90273f2c-9458-4320-8258-d3b9abf60fef}\begin{eqnarray}
\ket{\psi} &~=~& \sum_{i=1}^N a_i \ket{e_i}   ~= ~ \sum_{i=1}^N a_i \ket{e_i} + \sum_{i=1}^{N_2} a_{i+N_1} \ket{e_{i+N_1}} ~\equiv ~ \ket{\psi_1} + \ket{\psi_2}\rule{0mm}{5mm}
\end{eqnarray}
\sphinxAtStartPar
con \(\braket{\psi_1}{\psi_2} = 0\).

\sphinxAtStartPar
Decimos que el espacio \(\Hil\) se descompone en la \sphinxstyleemphasis{suma directa de subespacios ortogonales}
\begin{equation*}
\begin{split}
\Hil = \Hil_1 \oplus \Hil_2 
\end{split}
\end{equation*}
\sphinxAtStartPar
de dimensiones \(N_1 + N_2 = N\),

\sphinxAtStartPar
Los operadores
\begin{equation*}
\begin{split}
P_1 = \sum_{i=1}^{N_1} \ket{e_i}\bra{e_i} ~~~~~~~,~~~~~~~~ P_2 = \sum_{i=1}^{N_2} \ket{e_{i+N_1}}\bra{e_{i+N_1}}
= I - P_1
\end{split}
\end{equation*}
\sphinxAtStartPar
Verifican la ecuación que define un proyector
\begin{equation*}
\begin{split}
P_1^2 = P_1~~~~~,~~~~P_2^2 = P_2
\end{split}
\end{equation*}
\sphinxAtStartPar
Su acción extrae de un vector su componente en el subespacio asociado
\begin{equation*}
\begin{split}
P_1 \ket{\psi} ~=~ \sum_{i=1}^{N_1} \ket{e_i}\bra{e_i} \left(\sum_{k=1}^N a_k \ket{u_k} \right) ~=~
\sum_{i=1}^{N_1} a_i \ket{e_i} ~=~ \ket{\psi_1}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
P_2 \ket{\psi} ~=~ \sum_{i=1}^{N_2} \ket{e_{i+N_1}}\bra{e_{i+N_1}} \left(\sum_{k=1}^N a_k \ket{u_k} \right) ~=~
\sum_{i=1}^{N_1} a_{i+N_1} \ket{e_{i+N_1}} ~=~ \ket{\psi_2}
\end{split}
\end{equation*}
\sphinxAtStartPar
Claramente verifican
\begin{equation*}
\begin{split}
(P_1 + P_2)\ket{\psi} = \ket{\psi}
\end{split}
\end{equation*}
\sphinxAtStartPar
En resumen, vemos que satisfacen
\begin{equation*}
\begin{split}
P_1 P_2 = P_2 P_1  = 0 ~~~,~~~~P_1 + P_2 = I
\end{split}
\end{equation*}
\sphinxAtStartPar
Notar que \(P_1 \neq P_v = \ketbra{v}{v}\) donde \(\ket{v} = \sum_i \ket{i}\). Este operador proyectaría cualquier vector en la dirección de \(\ket{v}\).


\subsection{Autovalores y autovectores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:autovalores-y-autovectores}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: Autovalores y autovectores

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Existen vectores, \(\ket{\lambda}\) para los cuales la la acción de un operador \(A\) devuelve un vector paralelo
\begin{equation*}
\begin{split}
A\ket{\lambda} = \lambda \ket{\lambda}\, 
\end{split}
\end{equation*}
\sphinxAtStartPar
Decimos que \(\ket{\lambda}\) es un autovector (o vector propio) de \(A\) con autovalor (o valor propio) asociado \(\lambda\in {\mathbb C}\)

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Supongamos que \(A\) tiene \(d\) vectores propios \(\ket{\lambda_j} = \sum_i v_{ij}\ket{e_i}, \, j=1,..,d\)

\sphinxAtStartPar
Sea \(U_{ij} = v_{ij}\) la matriz formada por las componentes de los vectores propios (apilados por columnas)

\sphinxAtStartPar
Entonces
\begin{equation*}
\begin{split}
A_{diag} = \begin{pmatrix} \lambda_1 & & \\ & \ddots & \\ & & \lambda_d \end{pmatrix} = U^{-1} A U
\end{split}
\end{equation*}
\sphinxAtStartPar
Si \(A\) es normal, la matriz \(U\), que diagonaliza, es unitaria \(U^{-1} = U^{\dagger}\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ en general una matriz no será normal }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,}\PYG{n}{d}\PYG{p}{)}\PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,}\PYG{n}{d}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{eigvals}\PYG{p}{,} \PYG{n}{eigvecs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{valprop =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{eigvals}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{verificamos que los autovectores son las columnas de v}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{m}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{}cambiar a otro valor}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{m}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{eigvals}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{*} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{m}\PYG{p}{]}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A|}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{lambda\PYGZus{}m }\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{rangle \PYGZhy{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{lambda\PYGZus{}m |}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{lambda\PYGZus{}m}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{rangle =  }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ diagonalizamos A }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{eigvecs}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{getI}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A\PYGZus{}}\PYG{l+s+si}{\PYGZob{}diag\PYGZcb{}}\PYG{l+s+s1}{ = U\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZhy{}1\PYGZcb{} A U = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U no es unitaria}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,}\PYG{n}{U}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
-0.7295770872 & -0.2507132779 + 0.2382776812 i  \\
 -0.2507132779 - 0.2382776812 i & 0.7295770872  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
valprop = [0.04510097+0.3274616j  0.81932658+0.99592662j]
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}
A|\lambda_m \rangle -\lambda_m |\lambda_m\rangle =  
\begin{bmatrix}
0  \\
 0  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{bmatrix}
0.5087716298 & -0.1688066649 + 0.1604337075 i  \\
 -0.1688066649 - 0.1604337075 i & 1.4912283702  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{veamos ahora una matriz normal}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}


\PYG{n}{eigvals}\PYG{p}{,} \PYG{n}{eigvecs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{valprop =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{eigvals}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{verificamos que los autovectores son las columnas de v}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{m}\PYG{o}{=}\PYG{l+m+mi}{1} \PYG{c+c1}{\PYGZsh{}cambiar a otro valor}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{m}\PYG{p}{]}\PYG{p}{)} \PYG{o}{\PYGZhy{}} \PYG{n}{eigvals}\PYG{p}{[}\PYG{n}{m}\PYG{p}{]} \PYG{o}{*} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,} \PYG{n}{m}\PYG{p}{]}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A|}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{lambda\PYGZus{}m }\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{rangle \PYGZhy{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{lambda\PYGZus{}m |}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{lambda\PYGZus{}m}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{rangle =  }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ diagonalizamos A }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{U} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{eigvecs}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A\PYGZus{}}\PYG{l+s+si}{\PYGZob{}diag\PYGZcb{}}\PYG{l+s+s1}{ = U\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{dagger\PYGZcb{} A U = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U es unitaria}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,}\PYG{n}{U}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZgt{}:17: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
\PYGZlt{}\PYGZgt{}:17: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
/tmp/ipykernel\PYGZus{}19338/3458884779.py:17: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
  array\PYGZus{}to\PYGZus{}latex(np.dot(U.getH(),np.dot(A,U)),prefix=\PYGZsq{}A\PYGZus{}\PYGZob{}diag\PYGZcb{} = U\PYGZca{}\PYGZob{}\PYGZbs{}dagger\PYGZcb{} A U = \PYGZsq{})
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\begin{bmatrix}
0 & 0  \\
 0 & 0  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
valprop = [1.+1.j 1.\PYGZhy{}1.j]
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}
A|\lambda_m \rangle -\lambda_m |\lambda_m\rangle =  
\begin{bmatrix}
0  \\
 0  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{bmatrix}
1 & 0  \\
 0 & 1  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar



\subsubsection{Subespacio Propio}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:subespacio-propio}}
\sphinxAtStartPar
Decimos que un autovalor \(\lambda_k\) es \(d_k\) veces degenerado si existen \(d_k\) autovectores linealmente independientes,  \(\ket{\lambda_k^{a}}\) con \(a=1,...,d_k\) asociados al \sphinxstylestrong{mismo} autovalor
\begin{equation*}
\begin{split}A\ket{\lambda_k^a} = \lambda_k \ket{\lambda_k^a}\end{split}
\end{equation*}
\sphinxAtStartPar
Dichos autovectores generan un subespacio propio \(S(\lambda_k)\subset \Hil\).

\sphinxAtStartPar
Por ejemplo,  sea \(\ket{u} = \sum_{a=1}^{d_k} c_a\ket{\lambda^a_k} \) una combinación de dichos vectores propios, entonces
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_03_Operadores_myst:89ccae85-eb30-4573-ab14-f95dd97acdb9}\begin{eqnarray}
A \ket{u} 
=  \sum_{a=1}^{d_k} c_a A\ket{\lambda^a_k}  =  \sum_{a=1}^{d_k} c_a \lambda_k\ket{\lambda^a_k}  =   \lambda_k \sum_{a=1}^{d_k} c_a \ket{\lambda^a_k}  =\lambda_k\ket{u}
\end{eqnarray}
\sphinxAtStartPar
Por tanto \(\ket{u}\in S(\lambda_k)\).
\begin{itemize}
\item {} 
\sphinxAtStartPar
El teorema de Gramm\sphinxhyphen{}Schmidt garantiza que podemos elegir (mediante un cambio adecuado) el conjunto \(\{\ket{\lambda_{k}^a}\}\in (\lambda_k), a=1,...,d_k\) de forma que que sea una  base ortonormal

\end{itemize}
\begin{equation*}
\begin{split}\braket{\lambda_{k}^a}{\lambda_{k}^b}=\delta_{ab}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El \sphinxstylestrong{proyector ortogonal} sobre el subespacio propio \(S(\lambda_k)\) será

\end{itemize}
\begin{equation*}
\begin{split}
P_k = \sum_{a=1}^{d_k} \ketbra{\lambda_{k}^a}{\lambda_{k}^a}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejemplo}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Llamemos \(R_z(\theta)\) el operador que efectúa una rotación  en el plano  \((x,y)\) de ángulo \(\theta\). Cuando \(\theta = \pi\) encontramos las siguiente acción sobre los tres elementos \(\{\hat{\bf x},\hat{\bf y},\hat{\bf z}\}\)
de la base cartesiana

\end{itemize}
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_03_Operadores_myst:a245dbed-7d7c-4b5e-a6eb-cf0d448c9234}\begin{eqnarray}
R_z(\pi)\hat{\bf x} &=&-\hat{\bf x}  \\ \rule{0mm}{6mm}
R_z(\pi)\hat{\bf y} &=& -\hat{\bf y}  \\ \rule{0mm}{6mm}
R_z(\pi)\hat{\bf z} &=& + \hat{\bf z}  
\end{eqnarray}\begin{itemize}
\item {} 
\sphinxAtStartPar
Vemos que hay un autovector \(\hat{\bf z}\) con autovalor \(+1\) y dos autovectores \(\hat{\bf x} \) y \(\hat{\bf y} \)
con autovalor \(-1\).

\item {} 
\sphinxAtStartPar
El espacio \({\mathbb R}^3\) se divide en dos subespacios propios de \(R_z(\pi)\), uno de dimensión 1 (a lo largo del eje \(\hat{\bf z}\)) y otro de dimensión 2 (en el plano \((\hat{\bf x},\hat{\bf y})\)).

\item {} 
\sphinxAtStartPar
Los proyectores asociados serán

\end{itemize}
\begin{equation*}
\begin{split}
P_{\hat{\bf z}}= \ket{\hat{\bf z}}\bra{\hat{\bf z}}=\begin{bmatrix} 0 & & \\ & 0 & \\ & & 1 \end{bmatrix}~~~,~~~
P_{\hat{\bf x}\hat{\bf y}}= \ket{\hat{\bf x}}\bra{\hat{\bf x}}+\ket{\hat{\bf y}}\bra{\hat{\bf y}}=\begin{bmatrix} 1 & & \\ & 1 & \\ & & 0 \end{bmatrix}~~~,~~~
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar



\subsubsection{Espectro de Operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:espectro-de-operadores}}

\paragraph{Espectro de Operadores Normales}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:espectro-de-operadores-normales}}
\sphinxAtStartPar
Recordemos la definición de un operador normal. \(N\) será un operador normal si conmuta con su adjunto
\begin{equation*}
\begin{split}
NN^\dagger = N^\dagger N
\end{split}
\end{equation*}
\sphinxAtStartPar
La importancia de los operadores normales radica en el siguiente lema

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
los autovectores de un operador normal asociados a dos autovalores distintos  son ortogonales
\begin{equation*}
\begin{split}
\lambda_i\neq \lambda_j~~~~\Longleftrightarrow ~~~~ \braket{\lambda_i}{\lambda_j} = 0
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba:}

\sphinxAtStartPar
De la ecuación de autovalores \(N\ket{\lambda_j} =  \lambda_j \ket{\lambda_j}\), y de \(NN^\dagger = N^\dagger N\), se sigue que
\begin{equation*}
\begin{split}
\bra{\lambda_j}(N^\dagger - \lambda_j^*)(N - \lambda_j) \ket{\lambda_j} = \bra{\lambda_j}(N - \lambda_j)(N^\dagger - \lambda_j^*) \ket{\lambda_j}  = 0\,
\end{split}
\end{equation*}
\sphinxAtStartPar
de donde obtenemos \((N^\dagger - \lambda_j^*) \ket{\lambda_j} = 0 \Rightarrow \bra{\lambda_j} N = \bra{\lambda_j}\lambda_j\). Entonces
\begin{equation*}
\begin{split}
\bra{\lambda_j}N\ket{\lambda_i} = \lambda_j \braket{\lambda_j}{\lambda_i} = \lambda_i \braket{\lambda_j}{\lambda_i} \, ,
\end{split}
\end{equation*}
\sphinxAtStartPar
de donde se sigue que, para \(\lambda_i \neq \lambda_j \Rightarrow \braket{\lambda_i}{\lambda_j} = 0\).

\sphinxAtStartPar
En general, cada autovalor \(\lambda_k\) será \(d_k \geq 1\) veces degenerado.

\sphinxAtStartPar
En ese caso hay  \(\{\ket{\lambda^a_k}\}, a=1,...,d_k\) autovectores que generan el subespacio propio, \(S(\lambda_k)\subset \Hil \), de dimensión \(d_k\).

\sphinxAtStartPar
Subespacios \(S(\lambda_k)\perp S(\lambda_j)\) son ortogonales para \(k\neq j\) según el lema.

\sphinxAtStartPar
En resumen: siempre podemos encontrar una base  ortonormal de \(\Hil\), formada por autovectores de un operador normal \(N\)
\begin{equation*}
\begin{split}
I = \sum_k\sum_{a=1}^{d_k} \ket{\lambda^a_k}\bra{\lambda^a_k} ~~~~~~~~~~~;~~~~~~~~~ \braket{\lambda^a_j}{\lambda^b_k} = \delta_{ab}\delta_{jk}
\end{split}
\end{equation*}
\sphinxAtStartPar
El proyector sobre el subespacio propio \(S(\lambda_k)\) será
\begin{equation*}
\begin{split}
P_k = \sum_{a=1}^{d_k} \ketbra{\lambda^a_k}{\lambda^a_k}
\end{split}
\end{equation*}

\paragraph{Espectro de Operadores Hermíticos}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:espectro-de-operadores-hermiticos}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
El espectro de un operador hermítico  \(A = A^\dagger\),  tiene dos propiedades importantes:
\begin{itemize}
\item {} \begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
los autovalores de un operador hermíticos son reales \(\lambda_i \in {\mathbb R}\).

\end{enumerate}

\item {} \begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
los autovectores \(\ket{\lambda_i}\) de un operador hermítico asociados a autovalores distintos son ortogonales

\end{enumerate}

\end{itemize}
\begin{equation*}
\begin{split}
\lambda_i\neq \lambda_j ~~~\Longleftrightarrow ~~~\braket{\lambda_i}{\lambda_j} = 0\, .
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Tomemos un autovector normalizado de \(A\), \(\ket{\lambda}\) de autovalor \(\lambda\).

\end{enumerate}
\begin{equation*}
\begin{split}
\lambda = \bra{\lambda}A\ket{\lambda} =  (\bra{\lambda}A^\dagger\ket{\lambda})^* = (\bra{\lambda}A\ket{\lambda})^*= \lambda^* .~~~
\end{split}
\end{equation*}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
\sphinxAtStartPar
De hecho esta propiedad es cierta para operadores \(N\), normales. Los operadores Hermíticos son normales.
De la ecuación de autovalores \(N\ket{\lambda_j} =  \lambda_j \ket{\lambda_j}\), y de \(NN^\dagger = N^\dagger N\), se sigue que

\end{enumerate}
\begin{equation*}
\begin{split}
\bra{\lambda_j}(N^\dagger - \lambda_j^*)(N - \lambda_j) \ket{\lambda_j} = \bra{\lambda_j}(N - \lambda_j)(N^\dagger - \lambda_j^*) \ket{\lambda_j}  = 0\,
\end{split}
\end{equation*}
\sphinxAtStartPar
de donde obtenemos \((N^\dagger - \lambda_j^*) \ket{\lambda_j} = 0 \Rightarrow \bra{\lambda_j} N = \bra{\lambda_j}\lambda_j\). Entonces
\begin{equation*}
\begin{split}
\bra{\lambda_j}N\ket{\lambda_i} = \lambda_j \braket{\lambda_j}{\lambda_i} = \lambda_i \braket{\lambda_j}{\lambda_i} \, ,
\end{split}
\end{equation*}
\sphinxAtStartPar
de donde se sigue que, para \(\lambda_i \neq \lambda_j \Rightarrow \braket{\lambda_i}{\lambda_j} = 0\).
\}

\sphinxAtStartPar
El conjunto de autovectores \(\ket{\lambda_i}\) de un operador hermítico forma una base ortogonal. Puede normalizarse para formar una base ortonormal
\begin{equation*}
\begin{split}
\braket{\lambda_i}{\lambda_j} = \delta_{ij}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe una función, \(random\_hermitian\), que genere una matriz hermítica de dimensión \(d\).

\sphinxAtStartPar
Comprueba en distintos casos que el espectro es real.
\end{sphinxadmonition}


\paragraph{Espectro de Operadores Unitarios}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:espectro-de-operadores-unitarios}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Los autovalores de un operador unitario son fases puras
\begin{equation*}
\begin{split}
U^\dagger = U^{-1} ~~~\Longleftrightarrow ~~~\lambda_i = e^{i\phi_i}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba}

\sphinxAtStartPar
aquí tu prueba


\paragraph{Espectro de Proyectores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:espectro-de-proyectores}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Lema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
los autovalores de un proyector sólo pueden ser \(~0~\) ó \(~1~\)
\begin{equation*}
\begin{split}
P^2= P ~~~\Longleftrightarrow ~~~\lambda_i \in \{0,1\}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba}

\sphinxAtStartPar
La ecuación
\begin{equation*}
\begin{split} P^2 = P ~~~~~\Rightarrow ~~~~~~~~ P^2 \ket{u} = P\ket{u} \end{split}
\end{equation*}
\sphinxAtStartPar
sólo tiene dos soluciones consistentes
\begin{equation*}
\begin{split}
P\ket{u} = \ket{u}~~~~~~~\hbox{y} ~~~~~~~~~~P\ket{u} = 0
\end{split}
\end{equation*}

\subsubsection{Operadores que conmutan}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operadores-que-conmutan}}
\sphinxAtStartPar
Cuando dos operadores conmutan se dan ciertas propiedades algebraicas que son muy ventajosas. En cierto modo se parecen más a c\sphinxhyphen{}números. Veamos la primera.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Dados dos operadores \(A\) y \(B\) que conmutan, existe una base \(\{\ket{\lambda_i}\}\) de autovalores simultáneos de ambos operadores, es decir
\begin{equation*}
\begin{split}
A = \lambda_i^A\ketbra{\lambda_i}{\lambda_i} ~~~~,~~~~~ B= \lambda_i^B\ketbra{\lambda_i}{\lambda_i} 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba}

\sphinxAtStartPar
Supongamos que \(A\) y \(B\) conmutan. Entonces la acción de \(A\) estabiliza los subespacios propios de \(B\).

\sphinxAtStartPar
Es decir, si \(\ket{\lambda}\) es autoestado de \(B\), entonces \(B\ket{\lambda} = \ket{\mu}\) también es autoestado con idéntico autovalor. Se comprueba fácilmente
\begin{equation*}
\begin{split}
A(B\ket{\lambda} ) = B(A\ket{\lambda}) = B(\lambda\ket{\lambda}) = \lambda (B\ket{\lambda})
\end{split}
\end{equation*}
\sphinxAtStartPar
Por tanto \(\ket{\lambda}\) y \(B\ket{\lambda}\) pertenecen al mismo subespacio propio. Esto es lo que se entiende por estabilizar el subespacio.

\sphinxAtStartPar
Si \(\lambda\) es degenerado esto sólo asegura que \(B\ket{\lambda} = \ket{\lambda'}\) pertenece al subespacio propio del mismo autovalor \(\lambda\).

\sphinxAtStartPar
Esto quiere decir que, dento de cada subespacio propio de \(B\), podemos escoger la base que queramos. En particular podemos escoger una base que diagonalice \(A\) dentro de dicho subespacio.

\sphinxAtStartPar
En otras palabras, dos operadores que conmutan son diagonalizables simultáneamente. Su matriz en la base \(\{\ket{\lambda_i}\}\) es
\begin{equation*}
\begin{split}
A = \begin{bmatrix} \lambda^A_1 & & &  \\ & \lambda^A_2 & &   \\ & & \ddots &  \\ & & & \lambda^A_n 
\end{bmatrix}~~~~~~~,~~~~~~~~
B = \begin{bmatrix} \lambda^B_1 & & &  \\ & \lambda^B_2 & &   \\ & & \ddots &  \\ & & & \lambda^B_n 
\end{bmatrix}\, .
\end{split}
\end{equation*}

\paragraph{Valores singulares}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:valores-singulares}}
\sphinxAtStartPar
Sea \(A\in \Lin(\Hil)\) un operador general. Entonces \(A^\dagger A\) es un operador hermítico que tiene autovalores positivos o cero \(\lambda_i\geq 0\)
\begin{equation*}
\begin{split}
A^\dagger A\ket{\lambda_i} = \lambda_i\ket{\lambda_i} ~~\Rightarrow ~~\lambda_i = \bra{\lambda_i} A^\dagger A\ket{\lambda_i} =\| A\ket{\lambda_i} \| \geq 0
\end{split}
\end{equation*}
\sphinxAtStartPar
Por tanto, podemos tomar su raíz cuadrada \(s_i = \sqrt{\lambda_i} \geq 0\)

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Se definen los valores singulares de  \(A\in \Lin(\Hil)\) como \(s_i =\sqrt{\lambda_i}\) donde \(\lambda_i\) son los autovalores del operador \(A^\dagger A\).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Los valores singulares son muy importantes para caracterizar la diferencia entre operadores, como veremos más adelante.


\paragraph{Representación espectral de proyectores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:representacion-espectral-de-proyectores}}
\sphinxAtStartPar
Sea \(A\) una matrix normal con autovalores  \(\lambda_i\) y autovectores \(\ket{\lambda_{i,p}}, p=1,...,g_i= {\rm deg}(\lambda_i)\),
\begin{equation*}
\begin{split}
P_i = \sum_{p=1}^{g_i} \ket{\lambda_{i,p}}\bra{\lambda_{i,p}} 
\end{split}
\end{equation*}
\sphinxAtStartPar
es un proyector sobre el subespacio propio asociado a  \(\lambda_i\).

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Supongamos que sólo conocemos el espectro de autovalores \(\{\lambda_i\}\) de \(A\)  y no sus autovectores. Aun así el proyector \(P_i\) se puede escribir como
\begin{equation*}
\begin{split}
P_i = \prod_{k\neq i}\frac{A -\lambda_k I}{ \lambda_i -\lambda_k}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Por construcción,  se cumple que
\$\(
 P_i \ket{\lambda_j} = \delta_{ij}\ket{\lambda_j}~~~~~,  ~~~~ ~~AP_i = \lambda_i A \, .
\)\$

\sphinxAtStartPar
Notar que el rango de \(P_i\) está incluido por construcción sin necesidad de conocer la base que genera el subespacio \(\{\ket{\lambda_{i,p}}\}\).


\subsubsection{Descomposición de Operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:descomposicion-de-operadores}}
\sphinxAtStartPar



\paragraph{Descomposición  espectral}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:descomposicion-espectral}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema: Descomposición espectral

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Para todo operador normal \(N\) existe una base de  autovectores ortonormales,  \(\{\ket{\lambda^a_k}\}\),  tales que\\
\(A\) admite la siguiente  descomposición espectral 
\begin{equation*}
\begin{split}
N = \sum_{k=1}^d \lambda_k   P_k\, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Aquí \(d=  {\rm dim}(\Hil)\) y \(P_k = \sum_{a=1}^{g_k} \ketbra{\lambda^a_k}{\lambda^a_k}\) es el proyector sobre el subespacio propio \(S(\lambda_k)\), donde \(\lambda_k\) es \(g_k\) veces degenerado.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
1 & 1  \\
 -1 & 1  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ Realizamos la descomposición espectral}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{eigvals}\PYG{p}{,} \PYG{n}{eigvecs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n}{eigvec0} \PYG{o}{=} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{P0} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{ket\PYGZus{}bra}\PYG{p}{(}\PYG{n}{eigvec0}\PYG{p}{,}\PYG{n}{eigvec0}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{P0}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P\PYGZus{}0=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{eigvec1} \PYG{o}{=} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{n}{P1} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{ket\PYGZus{}bra}\PYG{p}{(}\PYG{n}{eigvec1}\PYG{p}{,}\PYG{n}{eigvec1}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{P1}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P\PYGZus{}1=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{verificamos completitud}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{P0}\PYG{o}{+}\PYG{n}{P1}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{P\PYGZus{}0 + P\PYGZus{}1=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}
P_0=
\begin{bmatrix}
\frac{1}{2} & - \frac{i}{2}  \\
 \frac{i}{2} & \frac{1}{2}  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
P_1=
\begin{bmatrix}
\frac{1}{2} & \frac{i}{2}  \\
 - \frac{i}{2} & \frac{1}{2}  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
P_0 + P_1=
\begin{bmatrix}
1 & 0  \\
 0 & 1  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{A\PYGZus{}descomp\PYGZus{}espect} \PYG{o}{=} \PYG{n}{eigvals}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{P0}\PYG{o}{+}\PYG{n}{eigvals}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{P1}

\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{A\PYGZus{}descomp\PYGZus{}espect}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
1 & 1  \\
 -1 & 1  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
La matriz \(A_{ij}\) que expresa \(A\) en la base \(\ket{\lambda_i}\) es diagonal
\begin{equation*}
\begin{split}
A_{ij} = \bra{\lambda^a_i} A\ket{\lambda^b_j} =  \lambda_k \delta_{kj} \delta_{ab} =\begin{bmatrix} \lambda_1 &  &  &  &  \\ & \ddots & & & \\ & & \lambda_2 & &  \\&  & & \ddots & \\  & & & &  \lambda_N \end{bmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(\lambda_k\) aparecerá \(d_k\) veces repetido.

\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
El operador identidad tiene a cualquier vector por autovector \( I\ket{v} = \ket{v}\), con autovalores \(\lambda_ i = 1\). Por tanto, en cualquier base, la matriz asociada a \(I\) tiene la forma diagonal
\begin{equation*}
\begin{split}
I_{ij} = \delta_{ij} = \begin{pmatrix} 1 &  &  &  \\ & 1 & &  \\ & & \ddots & \\ & & &  1 \end{pmatrix}
\end{split}
\end{equation*}
\sphinxAtStartPar
La descomposición espectral de \(I\) no es otra que la relación de completitud, que es cierta \sphinxstyleemphasis{para cualquier base}, ya que todas las bases son bases de autoestados de \(I\)
\begin{equation*}
\begin{split}
I ~=~ \sum_{i=1}^N \ketbra{\lambda_i}{\lambda_i} ~=~ \sum_{i=1}^N \ketbra{e_i}{e_i}
\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe una función  \(spectral\_decomp\) en python, que devuelva las dos listas \(\lambda_i\) y \(P_i\) asociadas a la decomposición espectral de un operador diagonalizable \(A = \sum_i \lambda_i P_i\).
\end{sphinxadmonition}


\paragraph{Descomposición Polar (PD)}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:descomposicion-polar-pd}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Todo operador \(A\in \Lin(\Hil)\) admite la descomposición polar \(A = UR\) donde \(U\) es un operador unitario, y \(R\) es un operador semi\sphinxhyphen{}definido positivo (sólo tiene autovalores positivos o cero)

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
La descomposición polar es \sphinxstyleemphasis{única} y generaliza la representación polar de números complejos \(z = r e^{i\phi}\) a operadores.

\sphinxAtStartPar
El hecho de que \(r\geq 0\) es la contrapartida a que \(R\) sea semi\sphinxhyphen{}definida positiva.

\sphinxAtStartPar
El factor \(e^{i\phi}\) es análogo al hecho de que un operador unitario, como veremos, sólo tiene autovalores que son fases puras.

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe una función \(random\_unitary\) que genere una matriz unitaria de dimensión \(d\).
Comprueba en distintos casos que el espectro está formado por fases
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Método para construir una matriz unitaria arbitraria usando la descomposición polar\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{d} \PYG{o}{=} \PYG{l+m+mi}{3}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,}\PYG{n}{d}\PYG{p}{)}\PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{n}{d}\PYG{p}{,}\PYG{n}{d}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}u, s, vh = linalg.svd(A, full\PYGZus{}matrices=False)}
\PYG{n}{u}\PYG{p}{,}\PYG{n}{r} \PYG{o}{=} \PYG{n}{la}\PYG{o}{.}\PYG{n}{polar}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
    
\PYG{n}{R} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{r}\PYG{p}{)} 
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ verificamos que R sólo tiene autovalores no\PYGZhy{}negativos }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{Reigval}\PYG{p}{,} \PYG{n}{Reigvec} \PYG{o}{=} \PYG{n}{la}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{R}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{Reigval}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{U}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)} 
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Latex}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZdl{}U = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZdl{}\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{k}{MatrixToLatex}(U)))

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Verifiquemos unitariedad \PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{Latex}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}\PYGZdl{}U\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{dagger\PYGZcb{}U = }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZdl{}\PYGZdl{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{k}{MatrixToLatex}(np.dot(U.getH(),U))))

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} verificamos que los autovalores de U son fases\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{p}{[}\PYG{n}{la}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{la}\PYG{o}{.}\PYG{n}{eig}\PYG{p}{(}\PYG{n}{U}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{conjugate}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[2.047\PYGZhy{}0.j 0.753+0.j 0.217+0.j]
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZgt{}:17: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
\PYGZlt{}\PYGZgt{}:17: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
/tmp/ipykernel\PYGZus{}19338/208356260.py:17: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
  display(Latex(\PYGZsq{}\PYGZdl{}\PYGZdl{}U\PYGZca{}\PYGZob{}\PYGZbs{}dagger\PYGZcb{}U = \PYGZpc{}s\PYGZdl{}\PYGZdl{}\PYGZsq{}\PYGZpc{}MatrixToLatex(np.dot(U.getH(),U))))
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}U = \begin{bmatrix} 0.13-0.44j&0.05+0.83j&0.27+0.16j \\0.21+0.32j&0.30-0.16j&0.45+0.73j \\0.24+0.77j&0.13+0.41j&0.07-0.40j \end{bmatrix}\end{split}
\end{equation*}\begin{equation*}
\begin{split}U^{\dagger}U = \begin{bmatrix} 1.00+0.00j&-0.00-0.00j&-0.00-0.00j \\-0.00+0.00j&1.00+0.00j&0.00+0.00j \\-0.00+0.00j&0.00-0.00j&1.00+0.00j \end{bmatrix}\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([1.+0.j, 1.+0.j, 1.+0.j])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\paragraph{Descomposición en Valores Singulares (SVD)}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:descomposicion-en-valores-singulares-svd}}
\sphinxAtStartPar
Vamos a enunciar este teorema para matrices. Concretamente el teorema habla de una matriz \(m\times n\). Este tipo de matrices se corresponden con operadores \(O \in \Lin(\Hil_A,\Hil_B)\) entre espacios de dimensiones \(m\) y \(n\).

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Sea \(A\) una matriz compleja \(m\times n\). Entonces  admite la siguiente forma (descomposición en valores singulares)
\begin{equation*}
\begin{split}
A = U\,\Sigma\, V^{\dagger} \, ,
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(U\in U(m)\), \(V\in U(n)\) son matrices unitarias cuadradas y \(\,\Sigma \,\) es una matriz rectangular \(m\times n\) con los \(s_1, ...,s_r\) valores singulares  no nulos de \(A\)   en la diagonal, donde \(r\leq {\rm min}(m,n)\).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstyleemphasis{Prueba:} Tomemos \(m>n\) sin pérdida de generalidad.

\sphinxAtStartPar
Sean \(\ket{\lambda_i}\) los \(n\) autovectores de \(A^\dagger A\in H(n)\), hermítica de dimensión \(n\).

\sphinxAtStartPar
Supongamos que hay \(r\)  valores singulares \(s_i = \sqrt{\lambda_i}\) organicémolos en orden decreciente
\(\lambda_1\geq \lambda_2\geq ... \geq \lambda_r > 0\) y \(\lambda_{r+1} = ... = \lambda_n = 0\).

\sphinxAtStartPar
Con la base ortonormal \(\ket{\lambda_i}\) podemos formar las siguientes matrices
\begin{equation*}
\begin{split}
\begin{array}{rcl}
V(n\times n) &=& \left(\rule{0mm}{3mm} \ket{\lambda_1},\ket{\lambda_2},....,\ket{\lambda_r},\ket{\lambda_{r+1}},...,\ket{\lambda_n}\right)
\nonumber \\
\Sigma(m\times n) &=&  \rule{0mm}{10mm} \left(
\begin{array}{ccccccc} 
\sqrt{\lambda_1} &\cdots  &    &  & & &  0  \\  \vdots & \ddots & & & & & \vdots  \\  & & \sqrt{\lambda_r} & & & &  \\
   & &  & 0  & &  &    \\ & & & & & \ddots &  \\  0 & &\cdots  & & & & 0  \\ \vdots & &&&& & \vdots \\ 0 & & \cdots & & & & 0
\end{array}
\right)
\nonumber \\
U(m\times m) &=& \rule{0mm}{8mm}\left( \rule{0mm}{3mm} \frac{1}{\sqrt{\lambda_1}}A\ket{\lambda_1}, \frac{1}{\sqrt{\lambda_2}}A\ket{\lambda_2}, ...., 
\frac{1}{\sqrt{\lambda_r}}A\ket{\lambda_r}, \ket{\mu_{r+1}},...\ket{\mu_m} \right) \, .
\nonumber 
\end{array}
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(\ket{\mu_{r+1}},...\ket{\mu_m}\) completa la base de vectores ortonormales.
Ahora podemos operar
\begin{equation*}
\begin{split}
\begin{array}{rcl}
U\Sigma V^\dagger &=& 
\left( \rule{0mm}{3mm} \frac{1}{\sqrt{\lambda_1}}A\ket{\lambda_1}, \frac{1}{\sqrt{\lambda_2}}A\ket{\lambda_2}, ...., 
\frac{1}{\sqrt{\lambda_r}}A\ket{\lambda_r}, \ket{\mu_{r+1}},...\ket{\mu_m} \right)
\begin{pmatrix} \sqrt{\lambda_1}\bra{\lambda_1} \\ \sqrt{\lambda_2}\bra{\lambda_2}  \\ \vdots \\ \sqrt{\lambda_r}\bra{\lambda_r} \\ 0 \\ \vdots \\ 0 \end{pmatrix} \nonumber\\
&=& A \sum_{i=1}^r \ket{\lambda_i}\bra{\lambda_i} = A \sum_{i=1}^n \ket{\lambda_i}\bra{\lambda_i} = A\, , \nonumber
\end{array}
\end{split}
\end{equation*}
\sphinxAtStartPar
donde usamos que \(A\ket{\lambda_i}=0\) para \(i>r\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ numpy tiene la función svd para descomponer en valores singulares}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the shape of A is :}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{A}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}


\PYG{n}{u}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{vh} \PYG{o}{=} \PYG{n}{la}\PYG{o}{.}\PYG{n}{svd}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{full\PYGZus{}matrices}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{the shape of u =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{u}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ s =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{s}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ v =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{vh}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}
A=
\begin{bmatrix}
-0.0244200116 + 0.1041895795 i & 0.9349803126 + 0.3421874814 i  \\
 -1.5492338807 - 0.1724318703 i & 1.2856329068 - 0.2683114857 i  \\
 0.9646564048 - 0.0099417172 i & -0.366942065 + 1.0589036124 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
the shape of A is : (3, 2)
the shape of u = (3, 3)  s = (2,)  v = (2, 2)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{U}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{u}\PYG{p}{)}
\PYG{n}{S}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{diag}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{V}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{vh}\PYG{p}{)}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{U}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{S}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{V}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}Verifiquemos unitariedad\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{U}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{U}\PYG{p}{)}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{U\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{dagger\PYGZcb{}U =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{V}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{n}{V}\PYG{p}{)}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{V\PYGZca{}}\PYG{l+s+s1}{\PYGZob{}}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{dagger\PYGZcb{}V =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}\PYGZgt{}:10: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
\PYGZlt{}\PYGZgt{}:11: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
\PYGZlt{}\PYGZgt{}:10: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
\PYGZlt{}\PYGZgt{}:11: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
/tmp/ipykernel\PYGZus{}19338/582162267.py:10: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
  display(array\PYGZus{}to\PYGZus{}latex(np.dot(U.getH(),U),prefix=\PYGZsq{}U\PYGZca{}\PYGZob{}\PYGZbs{}dagger\PYGZcb{}U =\PYGZsq{}))
/tmp/ipykernel\PYGZus{}19338/582162267.py:11: SyntaxWarning: invalid escape sequence \PYGZsq{}\PYGZbs{}d\PYGZsq{}
  display(array\PYGZus{}to\PYGZus{}latex(np.dot(V.getH(),V),prefix=\PYGZsq{}V\PYGZca{}\PYGZob{}\PYGZbs{}dagger\PYGZcb{}V =\PYGZsq{}))
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}
U=
\begin{bmatrix}
-0.1773651733 - 0.2087808279 i & -0.3952061246 - 0.6550921243 i & -0.2332610853 + 0.5340485512 i  \\
 -0.7632131121 - 0.1906945229 i & 0.3622448006 - 0.2161066755 i & 0.4293049613 - 0.1375325561 i  \\
 0.5160011558 - 0.1995903629 i & -0.1266866838 - 0.4697802904 i & 0.5980410426 - 0.3154526409 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
S=
\begin{bmatrix}
2.5414687533 & 0  \\
 0 & 0.9407201426  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
V=
\begin{bmatrix}
0.6679617784 & -0.7441955808  \\
 -0.6169703939 - 0.4161425184 i & -0.5537692673 - 0.3735137695 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
U^{\dagger}U =
\begin{bmatrix}
1 & 0 & 0  \\
 0 & 1 & 0  \\
 0 & 0 & 1  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
V^{\dagger}V =
\begin{bmatrix}
1 & 0  \\
 0 & 1  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Traza}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:traza}}

\paragraph{Traza de un operador}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:traza-de-un-operador}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
La traza de un operador \(A\) se define como la suma
\begin{equation*}
\tr A = \sum_ i \bra{e_i} A\ket{e_i} =  \sum_{i} A_{ii} 
\end{equation*}
\sphinxAtStartPar
de sus elementos de matriz diagonales  en cualquier base 

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Para ser consistente esta definición es necesario probar que no importa la base utilizada

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Lema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
La traza de un operador es independiente de la base en la que se calcule

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba}
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_03_Operadores_myst:00f33b55-16f4-468c-b4ce-b72e0b15b563}\begin{eqnarray}
{\rm tr} A  &=&\sum_i A_{ii} =\sum_{i} \bra{i}A\ket{i} =\sum_{i} \bra{i}A\left( \sum_j\ketbra{\tilde j}{\tilde j}\right)\ket{i}
\nonumber\\
&=& \sum_{ij}\bra{i}A\ket{\tilde j} \braket{\tilde j}{i} = \sum_{ij}\braket{\tilde j}{i}\bra{i}A\ket{\tilde j}  \nonumber\\
&=& \sum_{j} \bra{\tilde j}\left(\sum_i\ketbra{i}{i}\right) A \ket{\tilde j}= \sum_{j} \bra{\tilde j}A\ket{\tilde j}\nonumber\\
&=& \sum_j \tilde A_{jj}
\end{eqnarray}
\sphinxAtStartPar
Por esta importante propiedad la traza de \(A\) es la suma de sus autovalores
\begin{equation*}
\begin{split}
{\rm tr} A = \sum_i \bra{\lambda_i}A\ket{\lambda_i} = \sum_i \lambda_i
\end{split}
\end{equation*}
\sphinxAtStartPar
siempre que \(A\) sea diagonalizable en la base \(\ket{\lambda_i}\)
\begin{equation*}
\begin{split}
A\ket{\lambda_j} = \lambda_i \ket{\lambda_i}
\end{split}
\end{equation*}
\sphinxAtStartPar
La traza es una operación \sphinxstyleemphasis{lineal}
\begin{equation*}
\begin{split}
{\rm tr} (A + B ) = {\rm tr}A + {\rm tr}B
\end{split}
\end{equation*}
\sphinxAtStartPar
La traza de un producto de operadores tiene la propiedad de \sphinxstyleemphasis{cíclicidad}: es invariante bajo permutaciones  cíclicas de los operadores en su argumento. Por ejemplo, para tres operadores \(A, B\) y \(C\)
\begin{equation*}
\begin{split}
{\rm tr}(ABC)= {\rm tr}(BCA) 
\end{split}
\end{equation*}
\sphinxAtStartPar
Sea el operador \(A = \ketbra{u}{v}\) entonces
\begin{equation*}
\begin{split} \tr \left(\rule{0mm}{5mm}\ketbra{u}{v}\right) = \sum_i \braket{e_i}{u}\braket{v}{e_i} = \bra{v}\left(\sum_i \ketbra{e_i}{e_i}\right) \ket{u} = \braket{v}{u}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Demuestra este resultado
\end{sphinxadmonition}

\sphinxAtStartPar
Para un producto de dos operadores, el anterior resultado implica que la \sphinxstyleemphasis{traza de un conmutador es cero}. Dicho de otra forma
\begin{equation*}
\begin{split}
{\rm tr}(AB) = {\rm tr}(BA) ~~~\Rightarrow ~~~~{\rm tr}([A,B]) = 0 \, .
\end{split}
\end{equation*}
\sphinxAtStartPar



\paragraph{\protect\(\Lin(\Hil)\protect\) como un espacio de Hilbert}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:lin-hil-como-un-espacio-de-hilbert}}
\sphinxAtStartPar
Para transformar \(\Lin(\Hil)\) en un espacio de Hilbert sólo es necesario definir un producto escalar hermítico

\sphinxAtStartPar


\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: producto escalar

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Dados dos operadores \(A, B \in \Lin(\Hil)\)  definimos su  producto escalar   \(( A, B)\in {\mathbb C}\)
\begin{equation*}
\begin{split}
( A, B)= {\rm tr}\left( A^\dagger B \right) 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
En una base tenemos que
\begin{equation*}
\begin{split}
(A,B) = \sum_{ij} A^\dagger_{ij} B_{ji} = \sum_{ij} A^*_{ji} B_{ji}
\end{split}
\end{equation*}
\sphinxAtStartPar
mientras que
\begin{equation*}
\begin{split}
(B,A) = \sum_{ij} B^\dagger_{ij} A_{ji} = \sum_{ij} B^*_{ji} A_{ji}
\end{split}
\end{equation*}
\sphinxAtStartPar
Se sigue que  \((B,A) = (A,B)^*\). Además es trivial comprobar que  \((A,B+C) = (A,B) + (A,C)\), por lo que se trata de un producto escalar sesquilineal o hermítico.

\sphinxAtStartPar



\paragraph{\protect\(\Lin(\Hil)\protect\) como un espacio normado}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:lin-hil-como-un-espacio-normado}}
\sphinxAtStartPar
Una \sphinxstylestrong{norma} definida sobre \(\Lin(\Hil)  \)es un una función real \( A\to  \| A\| \in {\mathbb R}\) con las propiedades
que se han definido en una \DUrole{xref,myst}{sección anterior}

\sphinxAtStartPar


\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: \(p\)\sphinxhyphen{}norma Shatten

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Dado un operador \(A\in \Lin(\Hil)\) la función
\begin{equation*}
\begin{split}
\| A \|_p =  \left({\rm tr} \left(A^\dagger A\right)^{p/2} \right)^{1/p}
\end{split}
\end{equation*}
\sphinxAtStartPar
define una norma, denominada \(p\)\sphinxhyphen{}norma de Shatten.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Los tres casos más frecuentes son
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(p=1\) \sphinxstylestrong{norma de la traza} \(~\Rightarrow ~  \| A \|_1 =  {\rm tr} \sqrt{A^\dagger A}\)

\end{itemize}

\sphinxAtStartPar
Esta norma es igual a la suma de los valores singulares de \(A ~\Rightarrow ~\| A \|_1  = \sum_i^r s_i\), donde \(s_i^2\) son los autovalores de \(A^\dagger A\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(p=2\) \sphinxstylestrong{norma de Frobenius} \(~\Rightarrow ~ \| A \|_2 =  \sqrt{{ \rm tr} A^\dagger A }\)

\end{itemize}

\sphinxAtStartPar
La norma de Frobenius es la que se obtiene a partir  del producto escalar \(\|A\|_2 = (A,A)\)
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(p=\infty\) \sphinxstylestrong{norma espectral} \(~\Rightarrow ~  \| A \|_\infty = \lim_{p\to \infty} \| A \|_p\)

\end{itemize}

\sphinxAtStartPar
Puede demostrarse que la norma espectral es equivalente a la siguiente definición
\begin{equation*}
\begin{split}
\|A\|_\infty = \hbox{max}_{\ket{u}\in \Hil}\{ \|A\ket{u}\| ~~\hbox{con} ~ \|\ket{u}\| = 1\}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe, en python, una función \(trace\_norm(A)\), que calcule la norma de la traza de un operador.
\end{sphinxadmonition}


\paragraph{Distancia de traza}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:distancia-de-traza}}
\sphinxAtStartPar
Cualquier norma permite definir una noción de \sphinxstyleemphasis{distancia} o \sphinxstyleemphasis{diferencia} entre dos operadores.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: Distancia de traza

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Se define la   distancia de traza entre dos operadores \(A\) y \(B\) como la norma de la diferencia
\begin{equation*}
\begin{split}
d(A,B) = \| A - B \|_1 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{Funciones de Operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:funciones-de-operadores}}

\subsubsection{Funciones analíticas}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:funciones-analiticas}}
\sphinxAtStartPar
Estamos acostumbrados a escribir funciones \sphinxstyleemphasis{de una variable real o compleja}. Por ejemplo \(f(x)= x^2\), ó, \( f(z) = e^z\).

\sphinxAtStartPar
Querríamos dar sentido a una función \sphinxstyleemphasis{de un operador}
\(
A \to f(A)
\)

\sphinxAtStartPar
En el caso de que \(f(z)\) sea una función analítica expresable como una serie de Taylor en torno a \(x=0\)
\begin{equation*}
\begin{split}
f(z) = \sum_{n=0}^\infty \frac{1}{n!} f^{(n)}(0)\,  z^n
\end{split}
\end{equation*}
\sphinxAtStartPar
tomaremos como \sphinxstylestrong{definición} la \sphinxstyleemphasis{misma serie} cambiando el argumento \(x\to A\)
\begin{equation*}
\begin{split}
f(A) = \sum_{n=0}^\infty \frac{1}{n!} f^{(n)}(0)\,  A^n
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
De la misma forma que, para funciones analíticas \(f(z)^* = f(z^*)\), también la definición anterior asegura que
\(f(A)^\dagger = f(A^\dagger)\)
\end{sphinxadmonition}


\paragraph{Exponencial de un operador}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:exponencial-de-un-operador}}
\sphinxAtStartPar
la exponencial de un operador será
\begin{equation*}
\begin{split}
\exp(A) = e^A = I + A + \frac{1}{2} A^2 + \frac{1}{3!} A^3 + ...
\end{split}
\end{equation*}
\sphinxAtStartPar
Una propiedad importante de la función exponencial es  \(e^xe^y = e^{x+y}\).

\sphinxAtStartPar
La propiedad análoga para operadores \sphinxstyleemphasis{sólo es cierta cuando conmutan entre sí}.

\sphinxAtStartPar
Para el caso genérico tenemos dos opciones

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Sea \(A\) un operdor que verifique \(A^2 = I\), demuestra que se cumple la generalización de la ecuación de Euler
\begin{equation*}
\begin{split}
e^{i \alpha\, A} = \cos \alpha \, I + i \sin \alpha \, A
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Demuestra el teorema anterior
\end{sphinxadmonition}

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema: Baker\sphinxhyphen{}Campbel\sphinxhyphen{}Haussdorf

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Sean \(A,B\subset{\rm L}(\Hil)\) dos operadores lineales genéricos. Entonces
\begin{equation*}
\begin{split}
e^A e^B = e^{\left({A+B + \frac{1}{2}[A,B] + \frac{1}{12}[A,[A,B]]+ \frac{1}{12}[B,[B,A]] + ...}\right)}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Vemos que
\begin{itemize}
\item {} 
\sphinxAtStartPar
Si \(A\) y \(B\) conmutan,

\end{itemize}
\begin{equation*}
\begin{split}[A,B]=0 ~\Leftrightarrow ~e^A e^B = e^{A+B}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Si el conmutador de \(A\) y \(B\)  es un c\sphinxhyphen{}número

\end{itemize}
\begin{equation*}
\begin{split}[A,B]= c I  ~\Leftrightarrow ~  e^A e^B = e^{A+B + \frac{c}{2}}\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El inverso de \(e^A\) es \(e^{-A}\). Efectivamente, como

\end{itemize}
\begin{equation*}
\begin{split}[A,A]=0 \Rightarrow e^A e^{-A} = e^{A-A} = e^0 = I\end{split}
\end{equation*}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema: Lie\sphinxhyphen{}Suzuki\sphinxhyphen{}Trotter

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Sean \(A,B\subset{\rm L}(\Hil)\) dos operadores lineales genéricos. Entonces
\begin{equation*}
\begin{split}
e^{A+B} = \lim_{n\to\infty} \left(e^{{A/n}} e^{B/n}\right)^n
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Esta segunda opción es de uso muy frecuente en el contexto de la \sphinxstyleemphasis{simulación cuántica}.


\paragraph{Operadores unitarios a partir de hermíticos}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:operadores-unitarios-a-partir-de-hermiticos}}
\sphinxAtStartPar
Todo operador unitario \(U\) se puede expresar como la exponencial imaginaria de un operador hermítico \(H\)
\begin{equation*}
\begin{split}
U = e^{i H}
\end{split}
\end{equation*}
\sphinxAtStartPar
Efectivamente,
\begin{equation*}
\begin{split}U^\dagger = \left(e^{i H}\right)^\dagger = e^{-i H^\dagger} = e^{-i H}=U^{-1}\end{split}
\end{equation*}
\sphinxAtStartPar
por tanto, \(U\) es unitario si y sólo si \(H\) es hermítico.
\subsubsection*{Prueba}
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_03_Operadores_myst:1fb45fb7-58be-45b7-9f0d-07b58bd34f97}\begin{eqnarray}
U^\dagger &=& \left( e^{iH}\right)^\dagger = \left( 1+ iH + \frac{1}{2}(i H)^2 + ...\right)^\dagger \\
&=& 1 - iH^\dagger  + \frac{1}{2}(-i)^2 (H^2)^\dagger + ... \\
&=& 1 - iH +\frac{1}{2} H^2 - ... \\
&=& e^{-iH}\\ \rule{0mm}{6mm}
&=& U^{-1}
\end{eqnarray}

\subsubsection{Funciones  generales}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:funciones-generales}}
\sphinxAtStartPar
No siempre \(f(z)\) es analítica en torno a \(z0\). Es el caso,  por ejemplo \(f(z) = \exp(1/z)\). Por tanto, esta función no admite una expansión en serie de Taylor.

\sphinxAtStartPar
Aun así, si la función \(f(z)\) existe,  el operador \(f(A)\)  también. Para construirlo es necesario recurrir a la forma \sphinxstyleemphasis{forma diagonalizada}

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Sea \(A\) un operador diagonalizable, y sea \(A= \sum_i \lambda_i \ket{\lambda_i}\bra{\lambda_i}\) su representación espectral.
Entonces el operador \(f(A)\) tiene la representación espectral siguiente
\begin{equation*}
\begin{split}
f(A) = \sum_i f(\lambda_i) \ket{\lambda_i}\bra{\lambda_i}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
En otras palabras, si la matriz \(A^{(D)}_{ij} = \lambda_i \delta_{ij} \) es diagonal, cualquier función de la misma es, trivialmente, la matriz diagonal que se obtiene evaluando \(f(\lambda_i)\)
\begin{equation*}
\begin{split}
f(A^{(D)}_{ij}) = \begin{bmatrix} f(\lambda_1)& &  & \\ & f(\lambda_2) & &  \\ & & \ddots & \\ & & & f(\lambda_n)\end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejemplo 1}
\begin{equation*}
\begin{split}e^{1/A} = \sum_i e^{1/\lambda_i} \ket{\lambda_i}\bra{\lambda_i}\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejemplo 2}
\begin{eqnarray*}
{\rm tr}(A \log A) &=& {\rm tr}\left[\left(\sum_j \lambda_j \ket{\lambda_j}\bra{\lambda_j}\right)\left(\sum_k\log \lambda_k \ket{\lambda_k}\bra{\lambda_k}\right)\right] ~=~  {\rm tr}\left[\sum_k \lambda_k \log\lambda_k \ket{\lambda_k}\bra{\lambda_k} \right] \\ \rule{0mm}{20mm}
&=& {\rm tr} \begin{bmatrix} \lambda_1 \log \lambda_1& &  & \\ &\lambda_2 \log \lambda_2 & &  \\ & & \ddots & \\ & & & \lambda_n \log \lambda_n
\end{bmatrix}
 ~= ~ \sum_k \lambda_k \log \lambda_k \rule{0mm}{8mm}
\end{eqnarray*}\end{sphinxadmonition}


\subsection{Matrices de Pauli}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:matrices-de-pauli}}
\sphinxAtStartPar
Las matrices hermíticas forman un subespacio vectorial \(\hbox{Her}(\Hil)\subset \Lin(\Hil)\) que admite una base de matrices hermíticas

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Se definen las matrices de Pauli
\begin{equation*}
\begin{split}
\sigma_x = \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}~~~~~,~~~~~~~~~
\sigma_y = \begin{bmatrix} 0 & -i \\ i & 0 \end{bmatrix}~~~~~,~~~~~~~~~
\sigma_z = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix} \, .
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
También se usan los subíndices enteros \(\sigma_1=\sigma_x, ~
\sigma_2=\sigma_y\)  y  \(\sigma_3=\sigma_z\).
\end{sphinxadmonition}

\sphinxAtStartPar
Si añadimos la matriz identidad \(~I = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}~
\)  el conjunto \(\{I,\sigma_x,\sigma_y,\sigma_z\}\) forma una \sphinxstyleemphasis{base} para el espacio de \sphinxstyleemphasis{matrices hermíticas} \(2\times 2\).
\begin{eqnarray*}
A = a_0 I + {\bf a} \cdot \boldsymbol{\sigma}  &=&   a_0 I + a_1 \sigma_1 + a_2 \sigma_2 + a_3 \sigma_3  = 
\begin{bmatrix}
a_0 + a_3 & a_1 - i a_2 \\ a_1 + i a_2 & a_0 - a_3
\end{bmatrix} = A^\dagger
\end{eqnarray*}
\sphinxAtStartPar
con \(a_i\in {\mathbb R}\) cuatro números reales.

\sphinxAtStartPar
En total,  las matrices de Pauli poseen tres propiedades que las hacen únicas
\begin{itemize}
\item {} 
\sphinxAtStartPar
son hermíticas \(\sigma_i^\dagger = \sigma_i\)

\item {} 
\sphinxAtStartPar
son unitarias \(\sigma_i^\dagger = \sigma_i^{-1} = \sigma_i\)

\item {} 
\sphinxAtStartPar
tienen traza nula \(\tr(\sigma_i) = 0\)

\end{itemize}


\subsubsection{Composición}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:composicion}}
\sphinxAtStartPar
La composición de dos matrices de Pauli es otra matriz de Pauli que cumple la siguiente identidad
\begin{equation*}
\begin{split}
\sigma_i \sigma_j = \delta_{ij}I + i\epsilon_{ijk}  \sigma_k
\end{split}
\end{equation*}
\sphinxAtStartPar
donde
\begin{equation*}
\begin{split}
\epsilon_{123} = \epsilon_{231}=\epsilon_{312}=1~~~~,~~~~\epsilon_{213} = \epsilon_{132}=\epsilon_{321}=-1
\end{split}
\end{equation*}
\sphinxAtStartPar
Ejemplos:
\begin{eqnarray*}
\sigma_1\sigma_2 &=& i \sigma_3  \\
\sigma_2\sigma_1 &=& -i \sigma_3  \\
\sigma_2\sigma_1\sigma_2 &=& \sigma_2(i\sigma_3) = i^2 \sigma_1 = -\sigma_1\\
\sigma_2\sigma_2 &=& I
\end{eqnarray*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{s0} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{s1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{s2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{s3} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}


\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{verifica todas las opciones}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s1}\PYG{o}{*}\PYG{n}{s1}\PYG{o}{==}\PYG{n}{s0}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s1}\PYG{o}{*}\PYG{n}{s2}\PYG{o}{==}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{s3}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s2}\PYG{o}{*}\PYG{n}{s1}\PYG{o}{==}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{s3}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s2}\PYG{o}{*}\PYG{n}{s1}\PYG{o}{*}\PYG{n}{s2}\PYG{o}{==}\PYG{o}{\PYGZhy{}}\PYG{n}{s1}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{s1}\PYG{o}{*}\PYG{n}{s1}\PYG{o}{==}\PYG{n}{s0}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[[ True  True]
 [ True  True]]
[[ True  True]
 [ True  True]]
[[ True  True]
 [ True  True]]
[[ True  True]
 [ True  True]]
[[ True  True]
 [ True  True]]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Nota}

\sphinxAtStartPar
De las relaciones de composición anteriores se siguen inmediatamente las siguientes reglas de (anti) conmutación
\begin{equation*}
\begin{split}
\{\sigma_i,\sigma_j \} = 2\delta_{ij}~~~~~~~,~~~~~~~
~~~[\sigma_i,\sigma_j] = 2i\epsilon_{ijk}\sigma_k
\end{split}
\end{equation*}\end{sphinxadmonition}

\sphinxAtStartPar
Las matrices de Pauli tienen traza nula
\begin{equation*}
\begin{split}
{\rm tr} \, \sigma_i = 0
\end{split}
\end{equation*}
\sphinxAtStartPar
Tomando la traza de la relación de composición obtenemos que las matrices de Pauli \sphinxstyleemphasis{son ortogonales} en el sentido siguiente
\begin{equation*}
\begin{split}
(\sigma_i, \sigma_j) = {\rm tr}(\sigma_i\sigma_j) = {\rm tr}(\delta_{ij}I + i\epsilon_{ijk}  \sigma_k) = 2\delta_{ij}
\end{split}
\end{equation*}

\subsubsection{Exponenciación}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_03_Operadores_myst:exponenciacion}}
\sphinxAtStartPar
Consideremos  la  matriz hermítica siguiente
\begin{eqnarray*}
A &=& {\bf a} \cdot \boldsymbol{\sigma} 
\end{eqnarray*}
\sphinxAtStartPar
con \(a_i\in {\mathbb R}\) tres números reales.

\sphinxAtStartPar
Separemos \({\bf a}\) en un módulo y una dirección unitaria
\begin{equation*}
\begin{split}{\bf a} = (a_1,a_2,a_3) =a \left( \frac{a_1}{a},\frac{a_2}{a},\frac{a_3}{a}\right) =  a\, \hat{\bf n}\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(a=|{\bf a}|=\sqrt{a_1^2+a_2^3+a_3^2}~\)  y \(\hat{\bf n}\) es unitario

\sphinxAtStartPar
Entonces
\begin{equation*}
\begin{split}
{\bf a} \cdot \boldsymbol{\sigma} =  a\, \hat{\bf n} \cdot \boldsymbol{\sigma} = a A
\end{split}
\end{equation*}
\sphinxAtStartPar
Queremos hallar la exponencial \(e^{i {\bf a} \cdot \boldsymbol{\sigma}}\).

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}\begin{equation*}
\begin{split}
\exp \left( \rule{0mm}{4mm} i\,   {\bf a} \cdot \boldsymbol{\sigma}  \right) = (\cos a)\, I + i (\sin a)\,\hat{\bf n} \cdot  \boldsymbol{\sigma} \, 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Ejercicio}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Demuestra  que \((\hat{\bf n} \cdot \boldsymbol{\sigma})^2 = I\). Esto convierte al teorema anterior en un corolario.

\item {} 
\sphinxAtStartPar
Demuestra el teorema  a partir de  la descomposición espectral de las tres matrices de Pauli, \(\sigma_x, \sigma_y \) y \(\sigma_z\).

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k+kn}{import} \PYG{n}{expm}


\PYG{n}{avec} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{rand}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}
\PYG{n}{a} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{norm}\PYG{p}{(}\PYG{n}{avec}\PYG{p}{)}
\PYG{n}{nvec} \PYG{o}{=} \PYG{n}{avec}\PYG{o}{/}\PYG{n}{a}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{a}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{nvec}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{sigvec} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{s1}\PYG{p}{,}\PYG{n}{s2}\PYG{p}{,}\PYG{n}{s3}\PYG{p}{]}\PYG{p}{)}


\PYG{n}{adots}\PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{avec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{sigvec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exponentiating}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{e1} \PYG{o}{=} \PYG{n}{expm}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{adots}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{using the Euler\PYGZhy{}like formula}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ndots}\PYG{o}{=} \PYG{n+nb}{sum}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{nvec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{*}\PYG{n}{sigvec}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{e2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{n}{s0} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{nvec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{sigvec}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{nvec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{sigvec}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{+}\PYG{n}{nvec}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{o}{*}\PYG{n}{sigvec}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{verify}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{e1}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp(s1)=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{e2}\PYG{p}{,}\PYG{n}{prefix}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp(s1)=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
a= 0.8196453748381084
\end{sphinxVerbatim}
\begin{equation*}
\begin{split}\begin{bmatrix}
0.2089228489 & 0.2741500062 & 0.938718817  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
exp(s1)=
\begin{bmatrix}
0.6824804471 + 0.6861131983 i & 0.2003772952 + 0.1527025148 i  \\
 -0.2003772952 + 0.1527025148 i & 0.6824804471 - 0.6861131983 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}\begin{equation*}
\begin{split}
exp(s1)=
\begin{bmatrix}
0.6824804471 + 0.6861131983 i & 0.2003772952 + 0.1527025148 i  \\
 -0.2003772952 + 0.1527025148 i & 0.6824804471 - 0.6861131983 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope
\begin{quote}

\sphinxAtStartPar
Feb 13, 2024 | 8 min read
\end{quote}


\begin{wrapfigure}{r}{0.150\linewidth}
\centering
\noindent\sphinxincludegraphics[width=0.150\linewidth]{{Logo_TalentQ_Azul}.png}
\end{wrapfigure}


\section{Tensores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:tensores}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst::doc}}
\sphinxAtStartPar


\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ../../macro\PYGZus{}tQ.py
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{macro\PYGZus{}tQ} \PYG{k}{as} \PYG{n+nn}{tQ}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k}{as} \PYG{n+nn}{la}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,}\PYG{n}{Markdown}\PYG{p}{,}\PYG{n}{Latex}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{array\PYGZus{}to\PYGZus{}latex}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Producto Tensorial}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:producto-tensorial}}
\sphinxAtStartPar
Un computador clásico es capaz de tratar grandes cantidades de bits a base de acumular dispositivos de un solo bit. Cuánticamente consideraríamos una colección de sistemas que, cada uno, implemente un cúbit.

\sphinxAtStartPar
La herramienta matemática para describir un sistema compuesto es el \sphinxstyleemphasis{producto tensorial} de espacios de Hilbert

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
dados dos vectores \(\ket{u}_1\in \Hil_1\) y  \(\ket{v}_2\in \Hil_2\), denominamos producto tensorial al par ordenado
\begin{equation*}
\begin{split}
 \ket{u}_1\otimes \ket{v}_2 \equiv \ket{uv}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
con la propiedad \sphinxstyleemphasis{bilineal}. Es decir, como el producto ordinario, satisface la propiedad distributiva.
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_04_Tensores_myst:fcdbd556-f7c2-41f9-8185-2548c52466a7}\begin{eqnarray}
\big(\ket{u}+\ket{v}\big)\otimes \big(\ket{y}+\ket{z}\big) ~&\equiv &~~
\ket{u}\otimes\ket{y} ~+~ \ket{u}\otimes\ket{z} ~+~ \ket{v}\otimes\ket{y} ~+~~
 \ket{v}\otimes\ket{z} \\
 \rule{0mm}{8mm}
 &=& \ket{uy} + \ket{uz} + \ket{vy} + \ket{vz}
\end{eqnarray}
\sphinxAtStartPar
A continuación construimos un espacio vectorial, que incluya todas las posibles combinaciones lineales de pares ordenados.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
El  espacio producto tensorial  \(\Hil = \Hil_1 \otimes \Hil_2\) está formado por  todas las combinaciones lineales posibles de   pares ordenados
\begin{equation*}
\begin{split}
\ket{w}= a\ket{u}_1\otimes\ket{u}_2 ~+~ b \ket{v}_1\otimes\ket{v}_2 ~+ ~...
\end{split}
\end{equation*}
\sphinxAtStartPar
donde  \(\ket{u}_1,\ket{v}_1,...\in \Hil_1\, ~\) y \(~\, \ket{u}_2,\ket{v}_2,...\in \Hil_2~\),
y \(~a,b,... \in {\mathbb C}\) son coeficientes complejos.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Base y Dimensión}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:base-y-dimension}}
\sphinxAtStartPar
Sea \(\ket{i_1}\) una base de \(\Hil_1\) y \(\ket{i_2}\) una base de \(\Hil_2\). Entonces, una base de \(\Hil_1\otimes \Hil_2\) se obtiene
a partir de \sphinxstyleemphasis{todos} los emparejamientos
\begin{equation*}
\begin{split}
\ket{i_1 i_2} = \ket{i_1}\otimes \ket{i_2}~~~~~~~~~~~~~~~~~~ 
\end{split}
\end{equation*}
\sphinxAtStartPar
con
\(
i_1=1....d_1\) y \(i_2=1,...,d_2
\). Cada elemento así formado es linealmente independiente de los demás.

\sphinxAtStartPar
El número parejas posibles es \(d_1d_2\), que coincide con la \sphinxstylestrong{dimensión} de \(\Hil_1\otimes \Hil_2\).

\sphinxAtStartPar
Vemos que las \sphinxstylestrong{etiquetas} de los vectores de la base forman un \sphinxstyleemphasis{bi\sphinxhyphen{}índice} \(\to i_1 i_2\) que asume \(d_1 d_2\) parejas de valores distintos

\sphinxAtStartPar
Un \sphinxstyleemphasis{vector} se escribirá igualmente usando \(d_1 d_2\) componentes complejas \(w_{i_1 i_2}\), etiquetadas mediante un bi\sphinxhyphen{}índice en lugar de un índice
\begin{equation*}
\begin{split}
\ket{\omega} ~= ~ \sum_{i_1=1}^{d_1}\sum_{i_2=1}^{d_2} w_{i_1i_2} \ket{i_1 i_2} 
~=~ w_{11}\ket{11} + w_{12}\ket{12} + ... + w_{21}\ket{21} + ...\ldots + w_{d_1 d_2}\ket{d_1 d_2}   
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejemplo}

\sphinxAtStartPar
Supongamos que \(d_1 = 2\) y \(d_2=3\), entonces
\begin{equation*}
\begin{split}
\ket{w} = w_{11}\ket{11} + w_{12}\ket{12} + w_{13}\ket{13} + w_{21}\ket{21} + w_{22}\ket{22} + w_{23}\ket{23}
\end{split}
\end{equation*}
\sphinxAtStartPar
o, en notación matricial
\begin{equation*}
\begin{split}
\ket{w} \sim  \begin{pmatrix} w_{11}\\ w_{12} \\ w_{13} \\ w_{21} \\ w_{22} \\ w_{23} \end{pmatrix}
\end{split}
\end{equation*}\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Notar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Prescindiremos del subíndice \(\ket{u}_1\otimes \ket{y}_2=\ket{u}\otimes \ket{y} \equiv \ket{uy}\) que estará implícito en el orden.

\item {} 
\sphinxAtStartPar
Para computación cuántica con cúbits (cúdits), el valor relevante es \(d=2\,(d\geq 3)\).

\end{itemize}
\end{sphinxadmonition}


\subsubsection{Indexación equivalente}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:indexacion-equivalente}}
\sphinxAtStartPar
Podemos etiquetar las componentes (o los elementos de la base) con índices, en lugar de bi\sphinxhyphen{}índices

\sphinxAtStartPar
Para ello basta con definir un mapa  entre dos bi\sphinxhyphen{}índices \(i_1,i_2\) y un índice \(a\)
\begin{equation*}
\begin{split}
\ket{w} ~= ~ \sum_{i_1=1}^{d_1}\sum_{i_2=1}^{d_2} w_{i_1 i_2} \ket{i_1 i_2} ~=~ \sum_{a=1}^{d_1d_2} w_{a} \ket{a}
\end{split}
\end{equation*}
\sphinxAtStartPar
donde hemos querido resaltar que las componente y  los vectores son los mismos, etiquetados de forma diferente.

\sphinxAtStartPar
En el caso genera el mapa es
\begin{equation*}
\begin{split}
i_1 i_2 ~~\to ~~ a = d_2*(i_1-1) + i_2
\end{split}
\end{equation*}
\sphinxAtStartPar
Claramente \(a = 1,...,d_1d_2\) tiene \(d_1d_2\) valores distintos

\sphinxAtStartPar



\subsubsection{Producto de Kronecker}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:producto-de-kronecker}}
\sphinxAtStartPar
Como sabemos, cualquier vector admite, en una base, una representación como un vector columna con sus coeficientes como entradas.
\begin{equation*}
\begin{split}
\ket{w} ~= ~ \sum_{i,j=1}^2 w_{ij} \ket{e_{ij}}\sim~ \begin{pmatrix}w_{11}\\ w_{12}\\ w_{21} \\ w_{22}  \end{pmatrix}  ~  
\end{split}
\end{equation*}
\sphinxAtStartPar
La matriz columna asociada \(\ket{uv}= \ket{u}\otimes \ket{v}\) se forma a partir de las matrices columna de \(\ket{u}\) y \(\ket{v}\) mediante el denominado \sphinxstyleemphasis{producto de Kronecker} o, también \sphinxstyleemphasis{producto tensorial}.
\begin{equation*}
\begin{split}
 \ket{uv} = \ket{u}\otimes \ket{v} ~\sim~ 
\begin{pmatrix}u_1\\ u_2 \end{pmatrix}\otimes \begin{pmatrix}v_1\\ v_2 \end{pmatrix} ~\equiv ~
\begin{pmatrix}u_1 \begin{pmatrix}v_1\\ v_2 \end{pmatrix} \\ u_2 \begin{pmatrix}v_1\\ v_2 \end{pmatrix}  \end{pmatrix}
~=~\begin{pmatrix}u_1v_1\\ u_1v_2 \\ u_2 v_1 \\ u_2 v_2  \end{pmatrix}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
Con dos vectores \(\ket{u} = \sum_i u_i \ket{e_i}\) y \(\ket{v} = \sum_i v_i \ket{e_i} \in \Hil\), hay dos objetos muy parecidos que podemos formar
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
un operador \(\Omega = \ketbra{u}{v} = \sum_{ij}u_i v^*_j\ketbra{e_i}{e_j} \in \Lin(\Hil)\).

\item {} 
\sphinxAtStartPar
un vector \(\ket{\omega} = \ket{u}\otimes \ket{v} = \sum_{ij} u_i v_j \ket{e_i} \ket{e_j} \in \Hil\otimes \Hil\).

\end{enumerate}

\sphinxAtStartPar
Nota la conjugación compleja relativa entre las dos matrices de componentes \(\Omega_{ij} = u^*_i v_j\) y \(\omega_{ij} =  u_i v_j\).
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe una función  kronecker(u,v) que tome dos kets (como vectores columna)  y devuelva su producto de Kronecker. Verifica el resultado con la funcion \(kron\) de numpy.
\end{sphinxadmonition}


\subsection{Factorización y Entrelazamiento}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:factorizacion-y-entrelazamiento}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición: Vector entrelazado

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Decimos que, un vector \(\ket{w}\in \Hil\otimes\Hil\) es factorizable cuando es posible encontrar vectores \(\ket{u},\ket{v}\in \Hil\) tales que \( \ket{w} = \ket{u}\otimes\ket{v}\).

\sphinxAtStartPar
Cuando esto no sea posible, decimos que  \(\ket{w}\) es un vector entrelazado.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Ya hemos visto que, dada una base \(\ket{e_i}\) de \(\Hil\), el vector más general que pertenece al espacio producto admite una descomposición
\begin{equation*}
\begin{split}
\ket{w} = \sum_{i,j=1}^d w_{ij}\ket{e_{i}}\otimes \ket{e_j} = w_{11}\ket{e_1}\otimes\ket{e_1} + w_{12}\ket{e_1}\otimes\ket{e_2} + ...\, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Podría ocurrir que en otra base \(\ket{w} = \tilde w_{11} \ket{f_1}\otimes\ket{f_1}\) sólo tuviese un término y fuese factorizable.

\sphinxAtStartPar
Discernir si un vector es factorizable o entrelazado no es algo que se pueda hacer a primera vista.


\subsubsection{Criterio de factorizabilidad}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:criterio-de-factorizabilidad}}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
El estado es \(\ket{w}\) es factorizable si y sólo si las componentes \(w_{ij}\) son factorizables en la forma \(w_{ij} = u_i v_j~\) con \(i=1,...,d_1\) y \(j = 1,...,d_2\).

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba}
\begin{equation*}
\begin{split}
\ket{w}= \sum_{i,j=1}^d w_{ij} \ket{e_{ij}}  = \sum_{i,j} u_{i}v_j \ket{e_i}\otimes \ket{e_j}= \sum_{i,j} u_{i} \ket{e_i}\otimes v_j\ket{e_j}  ~ =~ \sum_i u_i\ket{e_i} \otimes \sum_j v_j\ket{e_j} ~=~   \ket{u}\otimes \ket{v}
\end{split}
\end{equation*}
\sphinxAtStartPar
identidad que se puede leer en ambos sentidos

\sphinxAtStartPar
El carácter entrelazado de un vector es genérico, mientras que el carácter factorizable es accidental.

\sphinxAtStartPar
Esto se sigue de un sencillo contaje:
\begin{itemize}
\item {} 
\sphinxAtStartPar
como función de \(d\),  \(\{w_{ij}\}\) forma un conjunto de \(d_1d_2\) parámetros complejos (grados de libertad).

\item {} 
\sphinxAtStartPar
sin embargo en \(\{u_i v_j\}\) sólo hay \(d_1 + d_2\) números independientes. Es evidente que \(d_1 d_2 \gg d_1 + d_2\).

\end{itemize}

\sphinxAtStartPar
En el caso  \(d_1 = d_2 =2\)  la condición de \sphinxstyleemphasis{factorizabilidad} \(~\Rightarrow ~w_{ij} = u_i v_j\) es equivalente a verificar
la anulación del  determinante de la matriz \(2\times 2\) formada por las componentes
\begin{equation*}
\begin{split}\det w_{ij} =  w_{11}w_{22}- w_{12}w_{21} = u_1v_1u_2v_2-u_1v_2u_2v_1=0\end{split}
\end{equation*}
\sphinxAtStartPar
En el caso general \(d_1, d_2 \geq 2\) la busqueda de un criterio para detectar si \(w_{ij}\) es factorizable o entrelazado pasa por la descomposición de Schmidt.

\sphinxAtStartPar



\subsubsection{Descomposición de Schmidt}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:descomposicion-de-schmidt}}
\sphinxAtStartPar
Supongamos que, en sendas bases arbitrarias \(\{\ket{e_{1,i}},~ i=1,...,d_1\}\)  de \(\Hil_1\) y  \(\{\ket{e_{2,a}},~a=1,...,d_2\}\)  de \(\Hil_2\) nuestro vector se escribe
\begin{equation*}
\begin{split}
\ket{w} = \sum_{i=1}^{d_1}\sum_{a=1}^{d_2} w_{ia} \ket{e_{1,i}}\otimes \ket{e_{2,a}}
\end{split}
\end{equation*}
\sphinxAtStartPar
Los valores de las \sphinxstyleemphasis{componentes} \(w_{ia}\) \sphinxstylestrong{dependen de las bases escogida}. En \sphinxstyleemphasis{otras} base \(\ket{ \tilde e_{1,i}}\otimes\ket{\tilde e_{2,a}}\) encontraremos \sphinxstyleemphasis{otras} componentes \(\tilde w_{ia}\) para el \sphinxstyleemphasis{mismo} vector

\sphinxAtStartPar
Si existe una base en la que \(\tilde w_{ia}=0\) para todos los \(i,a\) menos para uno (por ejemplo \(\tilde w_{11}\neq 0\)), entonces
\begin{equation*}
\begin{split}\ket{w}= \tilde w_{11}\ket{\tilde e_{1,1}}\otimes \ket{\tilde e_{2,1}}\end{split}
\end{equation*}
\sphinxAtStartPar
y, secretamente, el vector \(\ket{w}\) era factorizable.

\sphinxAtStartPar
El siguiente teorema nos permite averiguar \sphinxstylestrong{cuánto nos podemos acercar a esta situación}

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema: de Schmidt

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
para cada vector \(\ket{w}\in \Hil_1\otimes \Hil_2\), existen sendas  bases  \(\ket{f_{1,i}}\)  de \(\Hil_1\) y  \(\ket{f_{2,a}}\)  de \(\Hil_2\), tales que, podemos expresar
\begin{equation*}
\begin{split}
\ket{w} = \sum_{i=1}^r s_i \ket{f_{1,i}}\otimes\ket{f_{2,i}} \, ,
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(s_i>0\), y la suma   involucra el mínimo número, \(r\), de términos.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
El número \(1\leq r\leq {\rm min}(d_1,d_2)\) es rango de \(w\) y  se denomina  Número de Schmidt. Es la información relevante  porque
\begin{itemize}
\item {} 
\sphinxAtStartPar
cuando \(r=1\) el estado \(\ket{w}\) será \sphinxstyleemphasis{factorizable}.

\item {} 
\sphinxAtStartPar
si \(r\geq 2\) el estado será \sphinxstyleemphasis{entrelazado}.

\end{itemize}

\sphinxAtStartPar
La \sphinxstyleemphasis{demostración del Teorema de Schmidt} es interesante porque nos da un \sphinxstylestrong{método constructivo} para encontrar la descomposición.

\sphinxAtStartPar
Supongamos que nuestro vector se escribe
\begin{equation*}
\begin{split}
\ket{w} = \sum_{i=1}^{d_2}\sum_{a=1}^{d_2} w_{ia} \ket{e_{1,i}}\otimes \ket{e_{2,a}}
\end{split}
\end{equation*}
\sphinxAtStartPar
La matriz de coeficientes \(w_{ia}\) tiene  dimension \(d_1\times d_2\).
Asumiremos \(d_1 \geq d_2\) sin pérdida de generalidad

\sphinxAtStartPar
El \sphinxstylestrong{teorema SVD} de descomposición en valores singulares, nos garantiza que podemos expresar dicha matriz en la forma siguiente
\begin{equation*}
\begin{split}
w = U\Sigma V^\dagger ~~~\Rightarrow ~~~~w_{ia} = \sum_{j=1}^{d_1}\sum_{b=1}^{d_2} U_{ij}\Sigma_{jb}V_{ab}^*
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(U\) y \(V\) son unitarias \((d_1\times d_1)\) y \((d_2\times d_2)\) respectivamente, mientras que \(\Sigma\) es diagonal
\begin{equation*}
\begin{split}
\Sigma_{jb} = 
\overbrace{\left.
\begin{bmatrix}
s_1 &\cdots  &    &  & & &  0  \\  \vdots & \ddots & & & & & \vdots  \\  & & s_r & & & &  \\
   & &  & 0  & &  &    \\ & & & & & \ddots &  \\  0 & &\cdots  & & & & 0  \\ \vdots & &&&& & \vdots \\ 0 & & \cdots & & & & 0
\end{bmatrix}   \right\}  }^{\displaystyle d_2} \, d_1 ~~~~~~\Rightarrow ~~~~~ \Sigma_{jb} = s_j\delta_{jb}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Los números \(s_1,...,s_r >0\) son los autovalores de la matriz \(w^\dagger w\)  y se denominan valores principales   de la matriz \(w_{ij}\)

\end{itemize}

\sphinxAtStartPar
Esto quiere decir que podemos escribir
\begin{eqnarray*}
\ket{w} &=& \sum_{i=1}^{d_1}\sum_{a=1}^{d_2}\left( \sum_{j=1}^{d_1}\sum_{b=1}^{d_2} U_{ij}\Sigma_{jb}V_{ab}^* \right)\ket{e_{1,i}}\otimes \ket{e_{2,a}}
\\  \rule{0mm}{10mm}
&=& \sum_{j=1}^{d_1}\sum_{b=1}^{d_2}\Sigma_{jb}\left( \sum_{i=1}^{d_1} U_{ij}\ket{e_{1,i}} \right)\otimes  \left( \sum_{a=1}^{d_2} V_{ab}^* \ket{e_{2,a}}\right)
\\   \rule{0mm}{10mm}
&=& \sum_{j=1}^{d_1}\sum_{b=1}^{d_2}s_j\delta_{jb} \ket{f_{1,j}}\otimes \ket{f_{2,b}}\\   \rule{0mm}{10mm}
&=& \sum_{j=1}^r s_j \ket{f_{1,j}}\otimes \ket{f_{2,j}}
\end{eqnarray*}
\sphinxAtStartPar
Por tanto, podemos saber si un \sphinxstyleemphasis{estado bipartito} es entrelazado calculando la descomposición en valores singulares de su matriz de coeficientes en cualquier base.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Veamos el caso genérico}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{d1}\PYG{o}{=}\PYG{l+m+mi}{4} \PYG{c+c1}{\PYGZsh{} Dimensión de H1}
\PYG{n}{d2}\PYG{o}{=}\PYG{l+m+mi}{3} \PYG{c+c1}{\PYGZsh{} Dimensión de H2}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ generate a random complex matrix }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{d1}\PYG{p}{,}\PYG{n}{d2}\PYG{p}{)}\PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n}{d1}\PYG{p}{,}\PYG{n}{d2}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mi}{1}\PYG{n}{j}  \PYG{c+c1}{\PYGZsh{} coeficientes w\PYGZus{}\PYGZob{}ia\PYGZcb{} de un estado genérico}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ perform the SVD decomposition}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{u}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{vh} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{svd}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{full\PYGZus{}matrices}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{principal values s\PYGZus{}i = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The Schmidt number is r =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{count\PYGZus{}nonzero}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
-0.6771133129 - 1.7592191532 i & -0.169279762 + 0.9459507926 i & 0.9021837268 + 0.1822725284 i  \\
 0.1260322326 + 0.0055995793 i & 0.6940500089 - 0.2605170943 i & 2.4442163068 - 0.5115800371 i  \\
 0.3871659959 + 0.3934163266 i & -0.5397614987 - 2.1503665821 i & 0.4082058626 + 0.9059317522 i  \\
 0.0480247357 - 0.1089298156 i & -0.4562253407 + 0.8137884951 i & 0.7089854565 + 0.4507804966 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
principal values s\PYGZus{}i =  [3.274 2.697 1.388]
The Schmidt number is r = 3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Corre la celda anterior muchas veces y mira si consigues encontrar algún caso en que \(r<{\rm min}(d_1,d_2)\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Veamos ahora el caso particular de un estado factorizable}\PYG{l+s+s1}{\PYGZsq{}}

\PYG{n}{d1}\PYG{o}{=}\PYG{l+m+mi}{5}
\PYG{n}{d2}\PYG{o}{=}\PYG{l+m+mi}{3}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ create two random vectors }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{u} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{random\PYGZus{}ket}\PYG{p}{(}\PYG{n}{d1}\PYG{p}{)}
\PYG{n}{v} \PYG{o}{=} \PYG{n}{tQ}\PYG{o}{.}\PYG{n}{random\PYGZus{}ket}\PYG{p}{(}\PYG{n}{d2}\PYG{p}{)}

\PYG{n}{w} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{outer}\PYG{p}{(}\PYG{n}{u}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
\PYG{n}{display}\PYG{p}{(}\PYG{n}{array\PYGZus{}to\PYGZus{}latex}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ SVG decomposition }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{u}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{vh} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{svd}\PYG{p}{(}\PYG{n}{w}\PYG{p}{,} \PYG{n}{full\PYGZus{}matrices}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{principal values s\PYGZus{}i = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{The Schmidt number is p =}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{count\PYGZus{}nonzero}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}\begin{equation*}
\begin{split}\begin{bmatrix}
0.245547712 + 0.2501984358 i & -0.2719892208 + 0.0244247214 i & -0.1188884336 - 0.2626364848 i  \\
 -0.293928596 - 0.1611076509 i & 0.2421947252 - 0.0975627948 i & 0.1814381513 + 0.2075143255 i  \\
 -0.0446425495 - 0.0377016084 i & 0.0447581119 - 0.00828499 i & 0.0238162545 + 0.0417363197 i  \\
 -0.1655612383 + 0.1912009731 i & -0.0334657752 - 0.1941590325 i & 0.1819106228 - 0.1008476749 i  \\
 0.3671469454 - 0.023954469 i & -0.1668359102 + 0.2330500354 i & -0.2903014488 - 0.0853003486 i  \\
 \end{bmatrix}
\end{split}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
principal values s\PYGZus{}i =  [1. 0. 0.]
The Schmidt number is p = 1
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Podemos correr la celda anterior varias veces comprobar que nunca obtendremos \(r>1\)


\subsection{Producto Tensorial Múltiple}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:producto-tensorial-multiple}}
\sphinxAtStartPar
El producto tensorial se puede generalizar a más de un factor.

\sphinxAtStartPar
El espacio \( \Hil_1\otimes \Hil_2 ... \otimes \Hil_n\) formado por todas las \sphinxstyleemphasis{n\sphinxhyphen{}tuplas} ordenadas de vectores
\begin{equation*}
\begin{split}\ket{u} = \ket{u_1u_2...u_n} \equiv\ket{u_1}\otimes\ket{u_2}\otimes ...\otimes \ket{u_n}\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(\ket{u_i}\in 
\Hil_i\) y sus combinaciones lineales \(\{ a\ket{u}+ b\ket{v} + ...\}\).

\sphinxAtStartPar
Salvo mención expresa, asumiremos que todos los \(\Hil_j=\Hil\) son iguales y de dimension \(d\). En el contexto de la computación cuántica usual con cúbits \(\Rightarrow \, d=2\)

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe una función  kronecker(\(u_1,u_2,...,u_n\)) que tome n kets (como vectores columna)  y devuelva su producto de Kronecker múltiple.
\end{sphinxadmonition}


\subsubsection{Base de \protect\(\Hil^{\otimes n}\protect\)}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:base-de-hil-otimes-n}}
\sphinxAtStartPar
Una base de \(\Hil^{\otimes n}\) se obtiene a partir de cadenas
\begin{equation*}
\begin{split}\ket{i_1 i_2.... i_n} = 
\ket{i_1}\ket{i_2}  ... \ket{i_n}\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(i_1,..,i_n=0,...,d-1\).

\sphinxAtStartPar
El número de posibles cadenas es \(d^n\) que  es la dimensión de \(\Hil^{\otimes n}\)
\begin{equation*}
\begin{split}
{\rm dim}_{\mathbb C} \Hil^{\otimes n} = d^n
\end{split}
\end{equation*}
\sphinxAtStartPar
Podemos cambiar de etiqueta
\begin{equation*}
\begin{split}\ket{i_1...i_n} \to \ket{a}\end{split}
\end{equation*}
\sphinxAtStartPar
con
\begin{equation*}
\begin{split}
a = i_n + d i_{n-1} + d^2 i_{n-2} \, +...+ \,  d^{n-1} i_1
\end{split}
\end{equation*}
\sphinxAtStartPar
Claramente \(a ~\in ~(0,d^n-1)\).

\sphinxAtStartPar
Si cada base \(\{\ket{i}\}\) es ortonormal, tendremos que la \sphinxstyleemphasis{base producto} también lo será
\begin{equation*}
\begin{split}
\braket{i_1 i_2... i_n}{j_1j_2...j_n} = \delta_{i_1j_1}\delta_{i_2j_2}...\delta_{i_nj_n} ~~~~\leftrightarrow ~~~~
\braket{a}{b} = \delta_{ab}
\end{split}
\end{equation*}

\subsubsection{Estado entrelazado general}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:estado-entrelazado-general}}
\sphinxAtStartPar
Un \sphinxstyleemphasis{vector general} admitirá una expansión en esta base mediante \(d^n\) \sphinxstyleemphasis{componentes complejas}
\(u_{i_1 i_2...i_n}\) en la forma
\begin{equation*}
\begin{split}
\ket{u} ~~=~ \sum_{i_1,...,i_n=0}^{d-1} u_{i_1i_2...i_n} \ket{i_1i_2...i_n} ~~=~
 \sum_{a=0}^{d^n-1} u_a\ket{a}\, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Podemos obtener cualquier componente compleja proyectando sobre el elemento correspondiente de la base
\begin{equation*}
\begin{split}
u_{i_1i_2...i_n} = \braket{i_1 i_2... i_n}{u}~~~~~~\leftrightarrow~~~~~~~~u_a = \braket{a}{u}
\end{split}
\end{equation*}
\sphinxAtStartPar
Decimos que \(u_{i_1i_2...i_n}\) forman las componentes de un \sphinxstyleemphasis{tensor de rango} \(n\)

\sphinxAtStartPar
Un estado genérico depende de un conjunto de \(d*d...*d = d^n\) componentes independiente \(u_{i_1i_2...i_n}\).

\sphinxAtStartPar
Ya hemos visto los casos de rango \(n=1\) (vector) y \(n=2\) (operador)


\subsubsection{Estado factorizable}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:estado-factorizable}}
\sphinxAtStartPar
Al igual que antes, \sphinxstyleemphasis{sólo en casos muy particulares}, un vector de \(\Hil^{\otimes n}\) se podrá escribir en forma factorizada
\begin{equation*}
\begin{split}
\ket{w} = \ket{v_1}\ket{v_2}\ldots\ket{v_n} \equiv \ket{v_1 v_2 \ldots v_n}
\end{split}
\end{equation*}
\sphinxAtStartPar
Escribiendo \(\ket{v_k} = \sum_{i_k=1}^d v_{i_k}\ket{i_k}\) vemos que un \sphinxstyleemphasis{vector factorizable} admite una expansión general en la que los coeficientes son factorizables
\begin{equation*}
\begin{split}
v_{i_1i_2...i_n}  = v_{i_1} v_{i_2}.... v_{i_n}
\end{split}
\end{equation*}
\sphinxAtStartPar
El conjunto de coefficientes
está parametrizado por \(d +d + ...d = nd\) cantidades \(v_{i_k}, \, i_k=1,...,d, \, k=1,...,n\).


\subsubsection{Estados producto de matrices \sphinxstyleemphasis{(MPS)}}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:estados-producto-de-matrices-mps}}
\sphinxAtStartPar
En medio de los dos casos extremos anteriores encontramos la posibilidad de que las componentes del tensor se puedan escribir como productos de matrices.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Un estado \(\ket{v}\) es un MPS (estado producto de matrices) si sus componentes en cualquier base pueden escribirse como la traza total de un producto de matrices
\begin{equation*}
\begin{split}
v_{i_1 i_2 i_3... i_n} =\tr ( A^{(1)}_{i_1}\cdot A^{(2)}_{i_2}\cdot A^{(3)}_{i_3} \cdots A^{(n)}_{i_n} )
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
Si \(A^{(a)}_i\) con \(a=1,...,n\) y \(i=1,...,d\) es un conjunto  de \(nd\) matrices de dimensión \(D\times D\), con \(D\) la  \sphinxstyleemphasis{(dimensión local de enlace)}, el número de parámetros independientes es \(ndD^2\).
Los MPS tienen entrelazamiento no nulo, que crece con \(D\).

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Si \(A^{(a)}_i = A_i\) para todo \(a=1,..,n\) decimos que el MPS formado es \sphinxstyleemphasis{invariante traslacional}

\end{itemize}

\sphinxAtStartPar
Por ejemplo, con \(n=4\), \(\ket{v} =  v_{i_1i_2i_3i_4} \ket{e_{i_1i_2i_3i_4} }\)
\begin{equation*}
\begin{split}
v_{i_1i_2i_3i_4} =  \sum_{\alpha\beta\gamma\mu = 1}^DA_{i_1}^{\mu \alpha}A_{i_2}^{\alpha\beta}A_{i_3}^{\beta\gamma}A_{i_4}^{\gamma\mu}
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{XTN4}.png}
\end{figure}


\subsubsection{Redes de tensores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:redes-de-tensores}}
\sphinxAtStartPar
Si queremos aumentar el entrelazamiento del estado podemos, además de aumentar \(D\), recurrir a contracciones de índices de tensores de mayor rango
\begin{equation*}
\begin{split}
v_{i_1i_2i_3i_4} = \sum_{\alpha\beta\gamma\mu\delta = 1}^D A_{i_1}^{\mu \alpha\delta}A_{i_2}^{\alpha\beta}A_{i_3}^{\beta\delta\gamma}A_{i_4}^{\gamma\mu}
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{XTensNet}.png}
\end{figure}

\sphinxAtStartPar
Los estados MPS, y los estados TN  para una dimensión de enlace local \(D\) finita, no son suficientemente expresivos para capturar el máximo entrelazamiento posible en un estado.

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=500\sphinxpxdimen]{{XTN_complete}.png}
\end{figure}

\begin{sphinxadmonition}{note}{Notar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(nd \ll d^n\). El crecimiento exponencial del número de estados entrelazados es el ingrediente crucial para la computación cuántica. Observar que \(d^n\) es el número de enteros alcanzables por \(n\) bits. Pero en computación cuántica es el número de dimensiones en la que podemos poner \(d^n\) amplitudes complejas.

\item {} 
\sphinxAtStartPar
No existe un criterio general para saber si un estado es, a priori, factorizable o entrelazado.

\item {} 
\sphinxAtStartPar
Además, hay formas de caracterizar matemáticamente el nivel de entrelazamiento (\sphinxstyleemphasis{entanglement witnesses, entanglement monotones} etc.) desde nulo (estado factorizable) hasta maximal.

\end{itemize}
\end{sphinxadmonition}


\subsection{Operadores sobre  \protect\(\Hil^{\otimes n}\protect\)}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:operadores-sobre-hil-otimes-n}}
\sphinxAtStartPar
El espacio \(\Hil^{\otimes n}\) admite, como cualquier espacio vectorial, la acción de \sphinxstyleemphasis{operadores lineales} \(A: \Hil^{\otimes n} \to \Hil^{\otimes n}\) donde
\begin{equation*}
\begin{split}
A:\ket{u} \to \ket{v} \equiv A\ket{u}
\end{split}
\end{equation*}
\sphinxAtStartPar
El conjunto de todos los operadores lineales forman el espacio vectorial \(\Lin(\Hil^{\otimes n})\).


\subsubsection{Matrices}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:matrices}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A cada operador, \(A\), le podemos asociadar una \sphinxstyleemphasis{matriz}, una vez elijamos nuestra base  \(\{ \ket{i_1 i_2... i_n}\}\) donde, \(i_k = 1,...,d\).

\item {} 
\sphinxAtStartPar
Los \sphinxstyleemphasis{elementos de matriz} ahora vendrán etiquetados por dos \sphinxstyleemphasis{multi\sphinxhyphen{}índices}

\end{itemize}
\begin{equation*}
\begin{split}
 A_{i_1...i_n, \, j_1...j_n} = \bra{i_1...i_n}A\ket{j_1...j_n}  ~~~~~\leftrightarrow ~~~~~~ A_{ab}= \bra{a}A\ket{b}
 \end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Con la matriz, el operador se reconstruye en la base canónica de productos externos

\end{itemize}
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_04_Tensores_myst:22de7721-40ee-4af2-9ccf-9557c363a1df}\begin{eqnarray} 
 A &~~=~& 
 \sum_{i_1,...,i_n,\, j_1,...,j_n=0}^{d-1} A_{i_1...i_n, \, j_1...j_n} \ket{i_1...i_n}\bra{j_1...j_n}
 ~~~~=~~~~
  \sum_{a,b=a}^{d^{N}-1} A_{ab} \ket{a}\bra{b}
\end{eqnarray}\begin{itemize}
\item {} 
\sphinxAtStartPar
En \(A_{i_1...i_n,\,j_1...j_n} = A_{ab}\) hay \(d^n\times d^n = d^{2n}\) grados de libertad. Esta sería la dimensión del espacio  \(\Lin(\Hil^{\otimes n})\).

\end{itemize}


\subsubsection{Producto tensorial de operadores}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:producto-tensorial-de-operadores}}
\sphinxAtStartPar
En \(\Lin(\Hil^{\otimes n})\) hay un análogo de los vectores factorizables de \(\Hil^{\otimes n}\): los \sphinxstyleemphasis{operadores factorizables}.

\sphinxAtStartPar
Supongamos que existen \(n\) operadores lineales \(A^{(a)}\, ,\, a=1,...,n\) definidos sobre cada espacio factor \(\Hil\).

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Definición:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
La acción del producto tensorial de operadores  \(A = A^{(1)}\otimes A^{(2)} \otimes ...A^{(n)}\) sobre un vector \(\ket{v} = \ket{v}_1\otimes ...\otimes \ket{v_n}\in \Hil~\)   factoriza
\begin{equation*}
\begin{split}
A\ket{v} = A^{(1)}\ket{v_1}\otimes ... \otimes A^{(n)} \ket{v_n}\, .
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
La acción sobre vectores generales se sigue imponiento linealidad
\begin{equation*}
\begin{split}
A(\ket{v} + \ket{w}) = A\ket{v} + A\ket{w}\, .
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El adjunto de un producto tensorial de operadores es el producto de los adjuntos (no se permuta el orden)

\end{itemize}
\begin{equation*}
\begin{split}
A^\dagger = A^{(1)\dagger} \otimes ... \otimes A^{(n)\dagger}
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El producto tensorial de operadores hermíticos es hermítico

\end{itemize}
\begin{equation*}
\begin{split} A^{(a)\dagger} = A^{(a)} ~~\Longrightarrow A^{\dagger} = A \end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El producto tensorial de operadores unitarios, es unitario

\end{itemize}
\begin{equation*}
\begin{split} A^{(a)\dagger} = A^{(a)\, -1} \,  ~~\Longrightarrow ~~A^{\dagger} = A^{-1} \end{split}
\end{equation*}
\sphinxAtStartPar



\subsubsection{Producto de Kronecker de matrices}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:producto-de-kronecker-de-matrices}}
\sphinxAtStartPar
¿Cómo será la matriz \(A_{i_1...i_n, \, j_1...j_n}\) de un operador factorizable, \( A = A^{(1)}\otimes A^{(2)} \otimes ...A^{(n)}\), en términos de las matrices  \( A^{(a)}_{ij}\) de sus factores?

\sphinxAtStartPar
Vamos a tomar  \(n=2\) por simplicidad
\begin{eqnarray*}
A = A^{(1)}\otimes  A^{(2)} &=&\left( \sum_{i_1i_2}A^{(1)}_{i_1 j_1} \ket{i_1}\bra{j_1}\right)\left( \sum_{i_2j_2}A^{(2)}_{i_2 j_2} \ket{i_2}\bra{j_2}\right)\\
&=& \sum_{i_1 i_2 , j_1 j_2} A^{(1)}_{i_1 j_1}A^{(2)}_{i_2 j_2}\ket{i_1 i_2}\bra{j_1j_2} \\
&=& \sum_{i_1 i_2 , j_1 j_2} A_{i_1i_2,\, j_1j_2}\ket{i_1 i_2}\bra{j_1j_2}
\end{eqnarray*}
\sphinxAtStartPar
Vemos que la matriz asociada a \(A\) se obtiene  a partir de las matrices de \(A^{(a)}\) mediante el  \sphinxstyleemphasis{producto exterior de las matrices}, o \sphinxstyleemphasis{producto de Kronecker}.
\begin{equation*}
\begin{split}
  A_{i_1i_2,\,j_1j_2} = A^{(1)}_{i_1j_1}A^{(2)}_{i_2 j_2} 
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El método para de \sphinxstylestrong{representar} matricialmente el producto de Kronecker de dos matrices \(A\otimes B\) es sencillo. Supongamos que \(d=2\) y tenemos un operador producto \(A\otimes B\). Entonces su matriz

\end{itemize}
\begin{equation*}
\begin{split}
(A\otimes B)_{ab} = \begin{pmatrix} A_{00}B & A_{01}B \\ A_{10}B & A_{11}B \end{pmatrix} = \begin{pmatrix} A_{00}B_{00} & A_{00}B_{01} & A_{01}B_{00} & A_{01}B_{01} \\
                A_{00}B_{10} & A_{00}B_{11} & A_{01}B_{10} & A_{01}B_{11} \\
                A_{10}B_{00} & A_{10}B_{01} & A_{11}B_{00} & A_{11}B_{01} \\
                A_{10}B_{10} & A_{10}B_{11} & A_{11}B_{10} & A_{11}B_{11} \end{pmatrix}.
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
El producto de Kronecker verifica las siguientes propiedades para dos matrices \(A\)  y \(B\) de dimensiones \(d_A\) y \(d_B\).

\end{itemize}
\begin{eqnarray*}
(A\otimes B)(C\otimes D) &=& (AC)\otimes (BD) \nonumber\\ \rule{0mm}{6mm}
\tr(A\otimes B) &=& (\tr A)(\tr B) \nonumber\\ \rule{0mm}{6mm}
A\otimes(B+D) &=& A\otimes B + A\otimes D \nonumber\\ \rule{0mm}{6mm}
(A\otimes B)^\dagger &=& A^\dagger\otimes B^\dagger \nonumber\\ \rule{0mm}{6mm}
(A\otimes B)^{-1} &=& A^{-1} \otimes B^{-1} \nonumber\\ \rule{0mm}{6mm}
\det (A\otimes B) &=& (\det A)^{d_B}(\det B)^{d_A}
\end{eqnarray*}
\sphinxAtStartPar
donde \(AC\) significa el producto de matrices \(A\) y \(C\)

\begin{sphinxadmonition}{note}{Ejercicio}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Demuestra estos resultados.

\item {} 
\sphinxAtStartPar
Rescribe la función \(kronecker\)  para que acepte  dos matrices \(A\)  y \(B\) de dimensiones \(d_A\) y \(d_B\) y devuelva su producto de Kronecker \(A\otimes B\). Verifica el resultado con la funcion kron de numpy.   Verifica las propiedades anteriores.

\end{enumerate}
\end{sphinxadmonition}

\sphinxAtStartPar
La generalización a todo \(n\) es obvia. El producto de Kronecker de \(n\) matrices \( A^{(a)}_{i_aj_a}\) asociadas a operadores \(A^{(a)}\) es
\begin{equation*}
\begin{split}
 A_{i_1...i_n,\,j_1...j_n} = A^{(1)}_{i_1j_1}...A^{(n)}_{i_n j_n} 
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Calcula \(\sigma_1\otimes \sigma_2\otimes \sigma_3\)
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
Observar que en un operador general, la matriz \( A_{i_1...i_n,\,j_1...j_n}\) tiene \(d^n\times d^n = d^{2n}\) entradas independientes.

\sphinxAtStartPar
Sin embargo
en un producto de Kronecker \(A^{(1)}_{i_1j_1}...A^{(n)}_{i_n j_n}\) sólo hay \(nd^2\).

\sphinxAtStartPar
Por tanto, los \sphinxstyleemphasis{operadores factorizables} forman un subconjunto muy pequeño dentro del conjunto de los operadores generales.
\end{sphinxadmonition}


\subsubsection{Generación de entrelazamiento}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_04_Tensores_myst:generacion-de-entrelazamiento}}
\sphinxAtStartPar
Supongamos que \(\ket{u} = \ket{u_1}\otimes\ket{u_2}\) es factorizable.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Si \(A=A_1\otimes A_2\) es un operador factorizable entonces

\end{itemize}
\begin{equation*}
\begin{split}\ket{v} = A\ket{u} = A_1\ket{u_1}\otimes A_2\ket{u_2} = \ket{v_1}\otimes \ket{v_2}\end{split}
\end{equation*}
\sphinxAtStartPar
también es factorizable.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Inversamente, la \sphinxstyleemphasis{acción de un operador no factorizable} \(A\neq A_1\otimes A_2\) genera estados entrelazados

\end{itemize}
\begin{equation*}
\begin{split}
\ket{v} = A\ket{u}  \neq \ket{v_1}\otimes \ket{v_2}
\end{split}
\end{equation*}
\sphinxAtStartPar
En lenguaje físico, lo que esto quiere decir es que para generar entrelazamiento debe haber \sphinxstyleemphasis{interacción} entre los grados de libertad que residen en \(\Hil_1\) y \(\Hil_2\). Si no hay interacción, estados factorizados seguiran siendo factorizables en el futuro.

\sphinxstepscope
\begin{quote}

\sphinxAtStartPar
Feb 13, 2024 | 3 min read
\end{quote}


\begin{wrapfigure}{r}{0.150\linewidth}
\centering
\noindent\sphinxincludegraphics[width=0.150\linewidth]{{Logo_TalentQ_Azul}.png}
\end{wrapfigure}


\section{Probabilidades}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:probabilidades}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst::doc}}
\sphinxAtStartPar


\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ../../macro\PYGZus{}tQ.py
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{macro\PYGZus{}tQ} \PYG{k}{as} \PYG{n+nn}{tQ}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k}{as} \PYG{n+nn}{la}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,}\PYG{n}{Markdown}\PYG{p}{,}\PYG{n}{Latex}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{array\PYGZus{}to\PYGZus{}latex}
\PYG{k+kn}{import} \PYG{n+nn}{copy} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Variables aleatorias}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:variables-aleatorias}}
\sphinxAtStartPar
Denotamos con \((X,p(X))\) una  \sphinxstyleemphasis{variable aleatoria} donde
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(X\) es el espacio muestral de valores \(\{x_1, x_2,....,x_n\}\) que pueden aparecer en una \sphinxstyleemphasis{consulta} la variable aleatoria

\item {} 
\sphinxAtStartPar
\(p(X)\) es la \sphinxstyleemphasis{distribución de probabilidad}

\end{itemize}


\subsubsection{Distribución de probabilidad}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:distribucion-de-probabilidad}}
\sphinxAtStartPar
Una distribución de probabilidad es una función real \(x\to p(x)\) que debe  verificar las dos condiciones siguientes
\begin{equation*}
\begin{split}
p(x) \in [0,1]~~~~~~~,~~~~~~~~\sum_{x\in X }p(x) = 1 
\end{split}
\end{equation*}
\sphinxAtStartPar
Es decir, la suma de probabilidades de todos los sucesos posibles debe ser la unidad.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Media: la media de una variable aleatoria  viene dada por la expresión
\begin{equation*}
\begin{split}
\overline X  = \sum_i x_i p(x_i)
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Varianza: la varianza, \(\sigma_X^2\), es la media de la desviación cuadrática \(\overline{(x_i - \overline{X} )^2}\)
\begin{equation*}
\begin{split} 
\sigma^2_X = \sum_j (x_j-\overline{X})^2 p(x_j) = \overline{X^2} - \overline{X}^2
\end{split}
\end{equation*}
\sphinxAtStartPar
La cantidad \(\sigma_X\) se denomina  desviación estándar
\begin{equation*}
\begin{split}
\sigma_X = \sqrt{\overline{X^2} - \overline{X}^2}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsection{La conexión estadística}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:la-conexion-estadistica}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Nuestro conocimiento del mundo se basa en la realización de experimentos, el resultado de los cuales es (empíricamente) aleatorio.

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Podemos pensar en el hecho de medir un sistema como la consulta de una variable aleatoria \((X,p(X))\) donde la distribución de probabilidad incorpora todo nuestro conocimiento acerca del sistema

\end{itemize}


\subsubsection{Frecuencias e Histogramas}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:frecuencias-e-histogramas}}
\sphinxAtStartPar
Cualquier consulta o medida da lugar a una \sphinxstyleemphasis{muestra} finita de valores \(A_N = (a_1,a_2,...,a_N)\) donde \(a_i\in \{x_1,...,x_n\}\) pueden repetirse en la muestra, con números de aparición \(n(x_i)\) tales que  \(n(x_1) +  \ldots + n(x_p) = N\).

\sphinxAtStartPar
Estos datos se pueden agrupar en intervalos o \sphinxstyleemphasis{bins} que eliminen cierta precisión numérica.

\sphinxAtStartPar
Por ejemplo, si truncamos nuestra precisión a las décimas de unidad,  \(13.10\) y \(13.19\) pertenecerán al mismo \sphinxstyleemphasis{bin}.

\sphinxAtStartPar
Un histograma es un diagrama en el que, por cada \sphinxstyleemphasis{bin}, hay una columna, cuya altura representa el número de sucesos que pertenecen a dicho \sphinxstyleemphasis{bin}

\sphinxAtStartPar
En el siguiente ejemplo, puedes ver cómo, la misma lista de datos conduce a distintos histogramas si cambias la anchura de los bins

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}

\PYG{n}{datos1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{12.2}\PYG{p}{,} \PYG{l+m+mf}{15.3}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mf}{12.8}\PYG{p}{,} \PYG{l+m+mf}{18.1}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mi}{20}\PYG{p}{,} \PYG{l+m+mf}{19.5}\PYG{p}{,} \PYG{l+m+mf}{20.2}\PYG{p}{,} \PYG{l+m+mf}{12.1}\PYG{p}{,} \PYG{l+m+mf}{12.4}\PYG{p}{,} \PYG{l+m+mf}{13.2}\PYG{p}{,} \PYG{l+m+mf}{17.9}\PYG{p}{,} \PYG{l+m+mf}{14.1}\PYG{p}{,} \PYG{l+m+mi}{15}\PYG{p}{,} \PYG{l+m+mf}{13.4}\PYG{p}{,} \PYG{l+m+mf}{11.1}\PYG{p}{,} \PYG{l+m+mf}{14.6}\PYG{p}{,} \PYG{l+m+mi}{13}\PYG{p}{,} \PYG{l+m+mf}{17.4}\PYG{p}{,} \PYG{l+m+mf}{19.2}\PYG{p}{]}
\PYG{n}{datos2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{10.}\PYG{p}{,}\PYG{l+m+mi}{20}\PYG{p}{)}
\PYG{n}{datos}  \PYG{o}{=} \PYG{n}{datos1}

\PYG{n}{anchura\PYGZus{}bins} \PYG{o}{=} \PYG{l+m+mf}{1.}\PYG{c+c1}{\PYGZsh{} para modificar la anchura de los bins}
\PYG{n}{num\PYGZus{}bins} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{datos}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{datos}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{n}{anchura\PYGZus{}bins}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}número de bins}
\PYG{n}{bins\PYGZus{}list} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{datos}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{datos}\PYG{p}{)} \PYG{o}{+} \PYG{l+m+mi}{1} \PYG{p}{,}\PYG{n}{num\PYGZus{}bins}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}calculamos los extremos de los intervalos}


\PYG{n}{counts}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignore} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{datos}\PYG{p}{,} \PYG{n}{bins} \PYG{o}{=} \PYG{n}{bins\PYGZus{}list}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}F2AB6D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{rwidth}\PYG{o}{=}\PYG{l+m+mf}{0.85}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Datos}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Frecuencia}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{xticks}\PYG{p}{(}\PYG{n}{bins\PYGZus{}list}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{a12b2646afab44fd2eba62ab7fc01b36580e34035f972cf7bdfc083f6243dae5}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Ley de los grandes números}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:ley-de-los-grandes-numeros}}
\sphinxAtStartPar
Las fracciones relativas tienden en el límite \(N\to \infty\) a la probabilidad relativa de aparición de  \(x_i\) en una sola tirada
\begin{equation*}
\begin{split}
f_N(x_i) = \frac{n(x_i)}{N}~~~\stackrel{N\to\infty}{\longrightarrow}~~~{p(x_i)}
\end{split}
\end{equation*}
\sphinxAtStartPar
Experimentalmente sólo tenemos acceso a las frecuencias relativas \(f_N(x_i)\) para un \(N\) grande aunque finito.

\sphinxAtStartPar
Igualmente, nuestro conocimiento de la  media \(\overline X\)  y la varianza \(\sigma_X^2\) siempre es aproximado, y se realiza a través de las medias y varianzas muestrales

\begin{eqnarray*}
\overline{A}_N = \sum_i x_i f_N(x_i)~~~&\stackrel{N\to\infty}{\longrightarrow}&~~~ \overline{X}\\
\sigma_{A_N}^2 = \sum_{i} (x_i - \overline{A}_N)^2 f_N(x_i) ~~~&\stackrel{N\to\infty}{\longrightarrow}&~~~ \sigma_X^2
\end{eqnarray*}


\subsection{Distribuciones frecuentes}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:distribuciones-frecuentes}}

\subsubsection{La distribución de Bernouilli}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:la-distribucion-de-bernouilli}}
\sphinxAtStartPar
Una variable aleatoria de Bernouilli \(X=(x,p(x))\) tiene dos posibles resultados
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{éxito} \(\to x=1\) con probabilidad \(p(1) = p\)

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{fracaso} \(\to x=0\) con probabilidad \(p(0) = 1-p\)

\end{itemize}

\sphinxAtStartPar
Podemos calcular fácilmente

\begin{eqnarray}
\overline X &=& \sum_i x_i p_i =1 \cdot p + 0\cdot (1-p) = p\\
\sigma^2 &=& \sum_i (x-\overline X )^2p_i = (1-p)^2 p +(0-p)^2(1-p) = p(1-p)
\end{eqnarray}


\subsubsection{Distribución binomial}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:distribucion-binomial}}
\sphinxAtStartPar
La variable aleatoria binomial \(X = (x,p(x))\) se define como
\begin{equation*}
\begin{split}
x = \hbox{número de $éxitos$ obtenidos en $n$ pruebas de Bernouilli sucesivas }
\end{split}
\end{equation*}
\sphinxAtStartPar
Claramente \(x \in (0,1,2,...n)\).

\sphinxAtStartPar
Ahora es muy sencillo obtener la probabilidad de un suceso con \(x\) éxitos
\begin{equation*}
\begin{split}
p(x) = \begin{pmatrix}n\\ x\end{pmatrix} p^x (1-p)^{n-x}
\end{split}
\end{equation*}
\sphinxAtStartPar
donde el primer factor tiene en cuenta las posibles ordenaciones en que aparecen \(x\) éxitos en \(n\) intentos.

\sphinxAtStartPar
Un cálculo un poco más largo permite ver que, ahora
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_05_Probabilidades_myst:2baffff7-0932-44a0-9b82-35228246f46a}\begin{eqnarray}
\overline X &=&  np\\ \rule{0mm}{7mm}
\sigma^2 &=& n p(1-p)
\end{eqnarray}

\subsubsection{La distribución normal}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:la-distribucion-normal}}
\sphinxAtStartPar
Vamos a estudiar la distribución normal centrada en \(\mu\) y con anchura \(\sigma\)
\begin{equation*}
\begin{split}
p(x) = \frac{1}{\sqrt{2\pi}\sigma} \exp \left({-\frac{(x-\mu)^2}{2\sigma^2}}\right)
\end{split}
\end{equation*}
\sphinxAtStartPar
Nos encontramos ante una variable aleatoria con un espacio muestral continuo \(x\in (-\infty,+\infty)\).
\label{equation:docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matemático/01_05_Probabilidades_myst:17309e7c-ec4d-44cd-93d4-2906cafa554d}\begin{eqnarray}
\overline{X} &=& \int_{-\infty}^{+\infty} xp(x) dx = \mu \\
\overline{(x-\overline X)^2} &=& \int_{-\infty}^{+\infty} (x-\mu)^2 p(x)dx =\sigma^2
\end{eqnarray}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generamos una instancia de la distribución normal}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.1} 
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{10000}
\PYG{n}{s} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{normal}\PYG{p}{(}\PYG{n}{mu}\PYG{p}{,} \PYG{n}{sigma}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}


\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{generamos una instancia de histograma con un número de bins}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{num\PYGZus{}bins}\PYG{o}{=}\PYG{l+m+mi}{100}
\PYG{n}{counts}\PYG{p}{,} \PYG{n}{bins}\PYG{p}{,} \PYG{n}{ignore} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{hist}\PYG{p}{(}\PYG{n}{s}\PYG{p}{,} \PYG{n}{num\PYGZus{}bins}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{extraemos los bins para hacer el plot de la funcion analítica}\PYG{l+s+s1}{\PYGZsq{}}


\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dibujamos la función analítica para comparar}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{k}{def} \PYG{n+nf}{gaussian}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,}\PYG{n}{mu}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{o}{/}\PYG{p}{(}\PYG{n}{sigma} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}\PYG{p}{)}\PYG{o}{*}\PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{p}{(}\PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{mu}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{/} \PYG{p}{(}\PYG{l+m+mi}{2} \PYG{o}{*} \PYG{n}{sigma}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{p}{)}
    
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,} \PYG{n}{gaussian}\PYG{p}{(}\PYG{n}{bins}\PYG{p}{,}\PYG{n}{mu}\PYG{p}{,}\PYG{n}{sigma}\PYG{p}{)}\PYG{p}{,}\PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{9d1724653656dd60434f4221bc79d7e3ace12e9ab3d94492613934d63087ccf0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
En el límite de número de eventos \(N\to \infty\), el histograma y la curva matemática confluyen.


\subsection{Probabilidades combinadas}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:probabilidades-combinadas}}
\sphinxAtStartPar
Las probabilidades combinadas son \sphinxstyleemphasis{la base de las correlaciones}. Es aquí donde la Mecánica Cuántica \sphinxstyleemphasis{predice} resultados diferentes a la Mecánica Clásica.

\sphinxAtStartPar
Ahora vamos a examinar variables aleatorias formadas por dos espacios muestrales \(X\) e \(Y\). Dependiendo de la forma en que combinemos la observación de cada una tendremos distintas distribuciones de probabilidad


\subsubsection{Probabilidad combinada}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:probabilidad-combinada}}
\sphinxAtStartPar
La  \sphinxstyleemphasis{probabilidad combinada} \(p(X,Y)\) asocia un número \(p(x,y)\) a la probabilidad de observación conjunta de \(x\) \sphinxstylestrong{e} \(y\).

\sphinxAtStartPar
Hay que tratar las parejas de eventos  como un solo evento  \(a = (x,y)\). Por eso, la condición de normalización ahora es
\begin{equation*}
\begin{split}
\sum_a p(a) = \sum_{xy} p(x,y) = 1\, .
\end{split}
\end{equation*}
\sphinxAtStartPar
La suma parcial sobre una de las dos variables conduce a sendas \sphinxstylestrong{distribuciones marginales}
\begin{equation*}
\begin{split}
q(x) = \sum_{y} p(x,y) ~~~~~~~~~ \tilde q(y) = \sum_{x} p(x,y)
\end{split}
\end{equation*}
\sphinxAtStartPar
Si la probabilidad combinada es el producto de las probabilidades de los miembros del par, decimos que \(X\) e \(Y\) son \sphinxstylestrong{variables aleatorias independientes}
\begin{equation*}
\begin{split}
p(x,y) = p(x) p(y)
\end{split}
\end{equation*}
\sphinxAtStartPar
La distribución de cada variable coincide con la que se deduce de marginalizar la otra
\begin{equation*}
\begin{split}
\sum_y p(x,y) = p(x)~~~~,~~~~\sum_x p(x,y) = p(y)
\end{split}
\end{equation*}

\subsubsection{Probabilidad condicionada}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:probabilidad-condicionada}}
\sphinxAtStartPar
La distribución de \sphinxstylestrong{probabilidad condicionada} \(p(X|Y)\) asigna un número \(p(x|y)\) a la probabilidad  de encontrar un suceso \(X=x\) una vez \sphinxstyleemphasis{sabemos} que \(Y=y\) ha sido el resultado de consultar \(Y\).

\sphinxAtStartPar
La manera de acceder experimentalmente a estas distribuciones, es efectuar un muestreo \((a_i,b_i)\), \(i=1,...,N\) de valores de \((X,Y)\) y \sphinxstyleemphasis{seleccionar} sólo aquellos sucesos donde \(b_i = y\) un valor concreto de \(Y\).


\paragraph{Teorema de Bayes}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_01_02_Formalismo_matem_xe1tico/01_05_Probabilidades_myst:teorema-de-bayes}}
\sphinxAtStartPar
Las probabilidades \sphinxstyleemphasis{condicionales} y \sphinxstyleemphasis{combinadas} no son independientes. Se relacionan de la forma siguiente
\begin{equation*}
\begin{split}
p(x,y)   = p(x|y)p(y) = p(y|x) p(x)= p(y,x)
\end{split}
\end{equation*}
\sphinxAtStartPar
La segunda igualdad conduce al \sphinxstyleemphasis{teorema de Bayes}

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema: de Bayes

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}\begin{equation*}
\begin{split}
p(x|y) = p(y|x) \frac{p(x)}{p(y)}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxstepscope
\begin{quote}

\sphinxAtStartPar
Feb 13, 2024 | 7 min read
\end{quote}


\begin{wrapfigure}{r}{0.150\linewidth}
\centering
\noindent\sphinxincludegraphics[width=0.150\linewidth]{{Logo_TalentQ_Azul}.png}
\end{wrapfigure}


\chapter{Fundamentos de Mecánica Cuántica}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:fundamentos-de-mecanica-cuantica}}\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst::doc}}
\sphinxAtStartPar

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{run} ../macro\PYGZus{}tQ.py
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{n}{sys}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k+kn}{import} \PYG{n+nn}{macro\PYGZus{}tQ} \PYG{k}{as} \PYG{n+nn}{tQ}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k}{as} \PYG{n+nn}{la}
\PYG{k+kn}{from} \PYG{n+nn}{IPython}\PYG{n+nn}{.}\PYG{n+nn}{display} \PYG{k+kn}{import} \PYG{n}{display}\PYG{p}{,}\PYG{n}{Markdown}\PYG{p}{,}\PYG{n}{Latex}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{qiskit}\PYG{n+nn}{.}\PYG{n+nn}{tools}\PYG{n+nn}{.}\PYG{n+nn}{visualization} \PYG{k+kn}{import} \PYG{n}{array\PYGZus{}to\PYGZus{}latex}
\PYG{k+kn}{import} \PYG{n+nn}{copy} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Axiomas}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:axiomas}}
\sphinxAtStartPar
La Mecánica Cuántica es una teoría fundamentada en unos pilares axiomáticos cuya selección admite cierta flexibilidad. La más aceptada constituye lo que se denomina la interpretación de Copenhagen.

\sphinxAtStartPar


\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Postulado I: Vector de estado

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
En un instante, \(t\), la máxima información accesible de un sistema cuántico aislado está asociada a un vector \(\ket{\psi}\), de norma unidad, \(\braket{\psi}{\psi}=1\), perteneciente a un espacio de Hilbert \(\Hil\), cuya dimensión compleja \(N\) equivale al número de grados de libertad del sistema.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\begin{itemize}
\item {} 
\sphinxAtStartPar
El vector de estado es el objecto matemático que contiene la máxima información accesible. La palabra \sphinxstyleemphasis{estado} es engañosa por cuanto parece indicar que el sistema \sphinxstyleemphasis{está} en alguna estado concreto.  El vector de estado recibe también el nombre de \sphinxstyleemphasis{función de onda}.

\item {} 
\sphinxAtStartPar
La dimensión de \(\Hil\) está relacionada con el número de grados de libertad del sistema.

\item {} 
\sphinxAtStartPar
La \sphinxstyleemphasis{fase global} del vector de estado no contiene información: dos vectores que difieran en una fase global representan al mismo estado ningún experimento permite distinguirlos

\end{itemize}
\begin{equation*}
\begin{split}
\ket{\psi} \sim \ket{\psi'} =  e^{i\varphi}\ket{\psi} \, ,
\end{split}
\end{equation*}
\sphinxAtStartPar
\(\bullet\) \sphinxstylestrong{Postulado  II:  \sphinxstyleemphasis{Evolución con el tiempo}}

\sphinxAtStartPar
Lo que caracteriza y distingue a un sistema cuántico de otro está contenido en un \sphinxstyleemphasis{operador hermítico} \(H = H^\dagger\) que se denomina \sphinxstylestrong{operador Hamiltoniano}

\sphinxAtStartPar
El operador Hamiltoniano  gobierna su evolución. Supongamos que el sistema se prepara a \(t=0\) en un cierto estado \(\ket{\psi(0)}\)

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Postulado  II: Evolución con el tiempo

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
El cambio continuo en el tiempo de  \(\ket{\psi(t)}\) de un sistema cuya dinámica está gobernada por un Hamiltoniano \(H(t)\),  es determinista y es solución de la Ecuación de Schrödinger
\begin{equation*}
\begin{split}
 \frac{\partial\ket{\psi(t)}}{\partial t} =-\frac{i}{\hbar} H(t) \ket{\psi(t)} \, \label{eqschr}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
La ecuación de Schrödinger es una ecuación diferencial ordinaria (una sola variable) para un vector.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Postulado III: Medidas de Von Neumann

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar

\begin{itemize}
\item {} 
\sphinxAtStartPar
A una magnitud física medible le está asociado   un operador hermítico  \( A= A^\dagger\) que denominamos observable.

\item {} 
\sphinxAtStartPar
Los resultados de una medición no pueden dar como resultado nada más que uno de los valores propios de \(A \Rightarrow \lambda_n\).

\item {} 
\sphinxAtStartPar
 Regla de Born: La probabilidad de obtener  el autovalor \(\lambda_k\) como resultado de una cierta medición, viene dada por
la expresión

\end{itemize}
\begin{equation*}
\begin{split}
p(\lambda_k)~ = ~|\braket{\lambda_k}{\psi}|^2
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(\ket{\lambda_k}\) es el autovector asociado.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Las magnitudes medibles son números reales, de ahí la exigencia de que \(A\) deba ser un operador hermítico

\begin{sphinxadmonition}{note}{Nota}
\begin{itemize}
\item {} 
\sphinxAtStartPar
La información contenida en \(\ket{\psi}\) es intrínsecamente probabilística: \(\psi\) codifica una distribución de probabilidad, \(p(\lambda_m)\), para cada posible resultado \(\lambda_m\).

\item {} 
\sphinxAtStartPar
\sphinxstyleemphasis{Muy importante}:  \((\lambda_m,p(\lambda_m))\) no es una pseudo\sphinxhyphen{}probabilidad sino, probablemente, la única verdadera variable aleatoria en el sentido puro de la palabra que existe en la naturaleza.

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
La fórmula para \(p(\lambda_k)\)  es cierta cuando el autovalor en cuestion es \sphinxstyleemphasis{no degenerado}.

\sphinxAtStartPar
Cuando \(\lambda_k\) tiene degeneración \(d_k\) debe generalizarse:
\label{equation:docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:dd454b5c-f43e-461c-bb13-9a7217a88754}\begin{eqnarray}
p(\lambda_k)~ &=& ~ \sum_{a=1}^{d_k}|\braket{\lambda^a_k}{\psi}|^2 = \bra{\psi}\left(
 \sum_{a=1}^{d_k}\ketbra{\lambda^a_k}{\lambda^a_k}\right) \ket{\psi}\nonumber\\
&=&  \bra{\psi}P_k\ket{\psi} \rule{0mm}{7mm}\\
\end{eqnarray}
\sphinxAtStartPar
La última expresión revela que \(p(\lambda_k)\) no es más que el \sphinxstyleemphasis{valor esperado del proyector} \(P_k = P^2_k\).

\sphinxAtStartPar
Esta es la razón por la que las medidas a las que se refiere este postulado se denominana \sphinxstyleemphasis{proyectivas}

\sphinxAtStartPar
Veremos en el \DUrole{xref,myst}{capítulo 5} que son un caso especial del tipo más general posible de medidas.

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Postulado IV: Colapso de la función de  onda

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Si el resultado de una medida  ha sido  \(\lambda_n\),
el estado del sistema,inmediatamente después de la medida,

\sphinxAtStartPar
viene dado por el vector propio\\
\(\ket{\lambda_n} \in \Hil\), normalizado \(|\braket{\lambda_n}{\lambda_n}|=1\)
\begin{equation*}
\begin{split}
\ket{\psi}~\stackrel{\lambda_n}{\Longrightarrow}~ \ket{\lambda_n} 
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\section{Medidas y valores esperados}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:medidas-y-valores-esperados}}\begin{itemize}
\item {} 
\sphinxAtStartPar
En Mecánica Cuántica especificamos un estado en las componentes de la expansión de un estado en \sphinxstyleemphasis{una base} ortonormal.
Existen infinitas bases posibles para expresar un vector. ¿Qué base es la mejor? La respuesta es que depende del proceso que estudiemos.

\end{itemize}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Por ejemplo, si el proceso es \sphinxstyleemphasis{la medida} de un cierto observable \(A=A^\dagger\), el resultado de nuestra medición sólo puede ser uno de los \sphinxstyleemphasis{valores propios} \(\lambda_i\)

\end{itemize}
\begin{equation*}
\begin{split}
A \ket{\lambda_k} = \lambda_k \ket{\lambda_k}\, 
\end{split}
\end{equation*}
\sphinxAtStartPar
donde \(\ket{\lambda_k}\) son los autovectores \({k=1,2,...}\) que forman una base ortonormal.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Ésta es la base natural adaptada a procesos de medida de \(A\). En particular para conocer \sphinxstyleemphasis{con qué probabilidad} se producirá cada resultado, expandiremos el estado

\end{itemize}
\begin{equation*}
\begin{split}
\ket{\psi} = \sum_{i=1}^N a_i \ket{\lambda_i}\, .
\end{split}
\end{equation*}
\sphinxAtStartPar
El axioma IV (regla de Born) afirma que la probabilidad de aparición del resultado \(\lambda_i\) es precisamente
\begin{equation*}
\begin{split}
p(\lambda_i)=|\braket{\lambda_i}{\psi}|^2  = |a_i|^2 \, .
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
La forma de tener acceso experimental a los números \(p(\lambda_i)\)  es mediante la \sphinxstylestrong{repetición estadística}. Si efectuamos la medida un número \(n\) de veces con \(n\to \infty\), y contamos la frecuencia de aparición de los distintos \(\lambda_i\), esto es

\end{itemize}
\begin{equation*}
\begin{split}
\frac{n(\lambda_i)}{n}\, .
\end{split}
\end{equation*}
\sphinxAtStartPar
en el límite \(n\to \infty\) dicha frecuencia experimental convergerá a la probabilidad teórica
\begin{equation*}
\begin{split}
\lim_{n\to\infty} \frac{n(\lambda_i)}{n} =  p(\lambda_i)  = |a_i|^2   \, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Vemos que, mediante repetición estadística, solamente podemos recuperar el \sphinxstyleemphasis{módulo de las amplitudes}
\begin{equation*}
\begin{split}
|a_i| = \lim_{n\to\infty} \sqrt{\frac{n(\lambda_i)}{n} }
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
En Computación Cuántica, almacenamos la información en las amplitudes \(a_i\) en una base dada (la base computacional). Vemos que sólamente su módulo \(|a_i|\) es recuperable a través de medidas.

\item {} 
\sphinxAtStartPar
Cada vez que seleccionamos un estado \(\ket{\psi}\), y un observable \(A\), se genera una variable aleatoria \((\lambda,p(\lambda))\, \to \) en cada medida de \(A\) sobre \(\ket{\psi}\) obtenemos un autovalor \(\lambda_i\) con una probabilidad \(p(\lambda_i)\).
La repetición del experimento permite reconstruir estimadores estadísticos.

\end{itemize}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Generaliza las expresiones anteriores al caso en que los autovalores \(\lambda_k\) puedan ser  \(d_k\) veces degenerados.
\end{sphinxadmonition}


\subsection{Valores esperados}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:valores-esperados}}
\sphinxAtStartPar


\sphinxAtStartPar
Rescribamos la probabilidad de encontrar \(\lambda_k\) en el caso de que sea \(d_k\) veces degenerado
\begin{eqnarray*}
p(\lambda_k) &=& \sum_{a=1}^{d_k} |\braket{\lambda^a_k}{\psi}|^2  = 
\sum_{a=1}^{d_k} \braket{\psi}{\lambda^a_k}\braket{\lambda^a_k}{\psi} \nonumber\\
&=&\bra{\psi} \left( \sum_{a=1}^{d_k} \ket{\lambda^a_k}\bra{\lambda^a_k}  \right) = \bra{\psi}P_k \ket{\psi} 
\end{eqnarray*}
\sphinxAtStartPar
donde
\begin{equation*}
\begin{split}
P_k = \sum_{a=1}^{d_k} \ket{\lambda^a_k}\bra{\lambda^a_k}
\end{split}
\end{equation*}
\sphinxAtStartPar
es el proyector sobre el subespacio propio

\sphinxAtStartPar
Por el \sphinxstyleemphasis{valor esperado} \(\langle A\rangle\) del \sphinxstyleemphasis{observable} \(A\) en el estado \(\ket{\psi}\), entendemos el \sphinxstyleemphasis{valor medio} de la variable aleatoria \(\lambda_n\) obtenida por el método descrito.
\label{equation:docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:6814e2ac-dfc8-40d8-acd4-80130eeab3c8}\begin{eqnarray}
\langle A\rangle &=  \sum_k \lambda_k p(\lambda_k)
   =  \sum_k \lambda_k \bra{\psi}P_k\ket{\psi}  
&= \bra{\psi}\left(\sum_k \lambda_k P_k  \right) \ket{\psi} 
\end{eqnarray}
\sphinxAtStartPar
Reconocemos entre paréntesis la descomposición espectral de \(A\). Llegamos así a la siguiente expresión para el valor esperado de un observable \(A\) en un estado \(\ket{\psi}\)

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}\begin{equation*}
\begin{split}\langle A \rangle=\bra{\psi}A \ket{\psi} \end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
En particular, las probabilidades mismas se pueden expresar como \sphinxstyleemphasis{valores esperados del proyector asociado}
\begin{equation*}
\begin{split}
p(\lambda_k ) =  \bra{\psi}P_k\ket{\psi} = \langle P_k\rangle 
\end{split}
\end{equation*}
\sphinxAtStartPar
El espectro de un observable está formado por números reales que podemos ordenar \(\lambda_{min}<...<\lambda_{max}\).

\sphinxAtStartPar
El valor esperado de un observable en uno de sus autoestados coincide con el autovalor asociado
\begin{equation*}
\begin{split}
\bra{\lambda_i}A \ket{\lambda_i} = \bra{\lambda_i}\lambda_i \ket{\lambda_i}  = \lambda_i \braket{\lambda_i}{\lambda_i} = \lambda_i
\end{split}
\end{equation*}
\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Lema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
El valor esperado de un observable \(A\) está acotado entre sus valores propios mínimo y máximo
\begin{equation*}
\begin{split}
\lambda_{min} \leq \bra{\psi}A\ket{\psi} \leq \lambda_{max}
\end{split}
\end{equation*}
\sphinxAtStartPar
y las desigualdades anteriores se saturan en los autoestados correspondientes

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Desviación estándar}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:desviacion-estandar}}
\sphinxAtStartPar


\sphinxAtStartPar
La \sphinxstyleemphasis{varianza}  es la media de la desviación cuadrática de la variable aleatoria \((\lambda,p(\lambda))\) es decir
\begin{equation*}
\begin{split}
~~\sigma ^2 = \overline{(\lambda_i-\bar\lambda_i)^2}= \overline{\lambda^2} - \overline{\lambda}^2
\end{split}
\end{equation*}
\sphinxAtStartPar
de aquí se sigue, para la desviación estándar

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}\begin{equation*}
\begin{split} \sigma = \sqrt{\bra{\psi}A^2\ket{\psi} - \bra{\psi} A\ket{\psi}^2}
\end{split}
\end{equation*}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\sphinxAtStartPar
Evaluada en un estado propio \(\ket{\lambda_i}\), la varianza de un operador es cero
\begin{equation*}
\begin{split}
\sigma^2 = \bra{\lambda_i}A^2\ket{\lambda_i} - \bra{\lambda_i} A\ket{\lambda_i}^2 = \bra{\lambda_i}\lambda_i^2\ket{\lambda_i} - \bra{\lambda_i} \lambda_i\ket{\lambda_i}^2 = 0
\end{split}
\end{equation*}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{vev\PYGZus{}sig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{ket}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{assert} \PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{ket}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ket}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}  \PYG{o}{==} \PYG{l+m+mf}{1.} \PYG{c+c1}{\PYGZsh{} chequeamos que la norma es unidad}
    \PYG{n}{bra} \PYG{o}{=} \PYG{n}{ket}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}
    
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{el valor esperado}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{vev} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{bra}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{ket}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{real}
   
    \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{la varianza}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{A2} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{p}{)}
    \PYG{n}{var}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{bra}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{A2}\PYG{p}{,}\PYG{n}{ket}\PYG{p}{)}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{\PYGZhy{}} \PYG{n}{vev}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}
    \PYG{n}{sig} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{var}\PYG{o}{.}\PYG{n}{real}\PYG{p}{)}\PYG{p}{)}
    
    \PYG{k}{return}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{vev}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{sig}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ definamos una matriz hermítica }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{c+c1}{\PYGZsh{}np.random.seed(10) }

\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{matrix}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}
\PYG{n}{A} \PYG{o}{+}\PYG{o}{=}  \PYG{n}{A}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{eigvals}\PYG{p}{,} \PYG{n}{eigvecs} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linalg}\PYG{o}{.}\PYG{n}{eigh}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}

\PYG{n}{np}\PYG{o}{.}\PYG{n}{round}\PYG{p}{(}\PYG{n}{eigvals}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
array([\PYGZhy{}2.2561,  0.8435,  4.7955])
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
A continuación evaluamos el valor esperado en un vector aleatorio, y en dos autovectores de \(A\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{definamos un ket}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{vec1} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} este es un autovector aleatorio}
\PYG{n}{vec2} \PYG{o}{=} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}           \PYG{c+c1}{\PYGZsh{} este es el autovector de autovalor mínimo}
\PYG{n}{vec3} \PYG{o}{=} \PYG{n}{eigvecs}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}          \PYG{c+c1}{\PYGZsh{} éste es un autovector de autovalor máximo}

\PYG{n}{ket} \PYG{o}{=} \PYG{n}{vec2}       \PYG{c+c1}{\PYGZsh{} elegimos uno }

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{normalizado}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{norma}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{ket}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{T}\PYG{p}{,}\PYG{n}{ket}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real} 
\PYG{n}{uket} \PYG{o}{=} \PYG{n}{ket}\PYG{o}{/}\PYG{n}{norma}


\PYG{n}{vev}\PYG{p}{,} \PYG{n}{sig} \PYG{o}{=} \PYG{n}{vev\PYGZus{}sig}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{uket}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}A\PYGZgt{}= }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{vev}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ sigma = }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{sig}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}A\PYGZgt{}=  \PYGZhy{}2.2561  sigma =  2.98e\PYGZhy{}08
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Evolución temporal}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:evolucion-temporal}}

\subsection{Ecuación de Schrödinger}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:ecuacion-de-schrodinger}}
\sphinxAtStartPar
El estado de un sistema \(\ket{\psi(t)}\) posee la máxima información instantánea accesible de un sistema, es decir, a un tiempo dado \(t\).

\sphinxAtStartPar
Dado \(\ket{\psi(t_0)}\) en un instante inicial \(t_0\), la evolución posterior obedece a la  ecuación diferencial de Schrödinger
\begin{equation*}
\begin{split}
 \displaystyle \frac{d}{d t}\ket{\psi(t)} =-\frac{i}{\hbar} H(t) \ket{\psi(t)} \, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Hemos enfatizado el hecho de que, en el caso más general, \(H(t)\) puede depender del tiempo.

\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
Las cantidades que entran en la ecuación de Schrödinger \sphinxstyleemphasis{tienen unidades}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(H\) tiene unidades de \sphinxstyleemphasis{energía}. En el SI (Sistema Iternacional) \(\to\) \(\hbox{Julios = J}\)

\item {} 
\sphinxAtStartPar
\(t\) tiene unidades de \sphinxstyleemphasis{tiempo}, en el SI \(\to\) \(\hbox{segundos = s}\)

\item {} 
\sphinxAtStartPar
\(\hbar\) es la constante de Planck, y  tiene unidades de \sphinxstyleemphasis{acción}= energía \(\times\)  tiempo. En el SI  \(\to \) \(\hbox{Julios}\cdot\hbox{segundo} =  \hbox{J}\cdot\hbox{s}\). \(~\) Se trata de una \sphinxstyleemphasis{cantidad universal}
\$\(
\boxed{\hbar = 1.054\times 10^{-34}~~ \hbox{J}\cdot\hbox{s}}
\)\$

\end{itemize}
\end{sphinxadmonition}


\subsubsection{Conservación de la probabilidad.}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:conservacion-de-la-probabilidad}}
\sphinxAtStartPar
La \sphinxstyleemphasis{hermiticidad} de \(H\) se relaciona directamente con la interpretación probabilística de \(\ket{\psi}\).

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
En la evolución temporal se conserva la norma del vector de estado

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}\subsubsection*{Prueba}
\begin{eqnarray*}
\frac{d}{dt}\|\ket{\psi}\|^2 = \frac{d}{dt}\braket{\psi(t)}{\psi(t)} &=& \left(\rule{0mm}{3mm}\frac{d}{dt}\bra{\psi(t)}\right)\ket{\psi(t)} + 
\bra{\psi(t)}\left(\frac{d}{dt}\ket{\psi(t)} \right)\nonumber\\
&=& \left(\bra{\psi(t)}\frac{i}{\hbar}H^\dagger\right)\ket{\psi(t)} + \bra{\psi(t)}\left(-\frac{i}{\hbar}H\ket{\psi(t)} \right) \nonumber\\
&=&\frac{i}{\hbar} \bra{\psi(t)}(H^\dagger - H)\ket{\psi(t)} = 0
\end{eqnarray*}
\sphinxAtStartPar
Es decir: \(\|\ket{\psi}\|\) no cambia con el tiempo, y
esto implica que la norma de \(\ket{\psi(t)}\) se conserva \(\Rightarrow 1 = \|\ket{\psi(0)}\| =\|\ket{\psi(t)}\|\)


\subsection{Operador de Evolución}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:operador-de-evolucion}}
\sphinxAtStartPar


\sphinxAtStartPar
La conservación de la norma implica que la evolución \(\|\ket{\psi(0)\|} =\|\ket{\psi(t)}\|\) es un \sphinxstyleemphasis{proceso unitario}.
En otras palabras, debe existir un operador unitario
\begin{equation*}
\begin{split}
U(t,t_0)^{-1}= U(t,t_0)^\dagger 
\end{split}
\end{equation*}
\sphinxAtStartPar
que lleve el estado inicial al actual a tiempo \(t\)
\begin{equation*}
\begin{split}
 U(t,t_0): \ket{\psi(t_0)}~~ \to~~ \rule{0mm}{3.5mm} \ket{\psi(t)} = U(t,t_0)\ket{\psi(t_0)}
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
El operador de evolución satisface las siguientes propiedades
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(U(t_0,t_0) = I\) , .

\item {} 
\sphinxAtStartPar
transitividad:  \(U(t,t_1)U(t_1,t_0)= U(t,t_0)\)

\item {} 
\sphinxAtStartPar
invertibilidad: \(U(t,t_0)^{-1} = U(t_0,t)\)

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
Evidentemente, el operador de evolución debe estar relacionado con el Hamiltoniano, que es quien gobierna la dinámica. Veamos a ver que hay una ecuación de Schrödinger también para el operador de evolución

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
El operador de evolución satisface la siguiente ecuación de evolución
\begin{equation*}
\begin{split}
 \frac{d}{dt}U(t,t_0) = -\frac{i}{\hbar} H(t)\, U(t,t_0)
\end{split}
\end{equation*}\subsubsection*{Demostración}

\sphinxAtStartPar
Tomando la derivada temporal de la ecuación \(\ket{\psi(t)} = U(t,t_0)\ket{\psi(t_0)}\), que define \(U(t,t_0)\), tenemos para cada miembro
\label{equation:docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:dc4e0f9b-34ea-4bc6-824e-b8c1b94dec69}\begin{eqnarray}
\frac{d}{dt}\ket{\psi(t)} &~=~& -\frac{i}{\hbar}  H(t)\ket{\psi(t)} = -\frac{i}{\hbar} H(t)U(t,t_0)\ket{\psi(t_0)}  \nonumber\\
\frac{d}{dt}U(t,t_0)\ket{\psi(t_0)} &~=~& \left(\frac{d}{dt}U(t,t_0)\right)\ket{\psi(t_0)}
\end{eqnarray}
\sphinxAtStartPar
Igualando ambas expresiones, y teniendo en cuanto que \(\ket{\psi_0}\) es arbitrario, obtenemos la ecuación deseada.

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}

\subsubsection{Caso de \protect\(H\protect\) independiente del tiempo}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:caso-de-h-independiente-del-tiempo}}
\sphinxAtStartPar
Cuando \(H\) no depende del tiempo podemos dar una expresión analítica para el operador de evolución

\begin{sphinxuseclass}{sd-card}
\begin{sphinxuseclass}{sd-sphinx-override}
\begin{sphinxuseclass}{sd-mb-3}
\begin{sphinxuseclass}{sd-shadow-sm}
\begin{sphinxuseclass}{sd-card-header}
\sphinxAtStartPar
Teorema:

\end{sphinxuseclass}
\begin{sphinxuseclass}{sd-card-body}
\sphinxAtStartPar
Para un hamiltoniano \(H\) independiente del tiempo, el operador de evolución \(U(t,t_0)\) es
\begin{equation*}
\begin{split}
U(t,t_0) = \exp\left({-\frac{i}{\hbar} (t-t_0)H}\right)
\end{split}
\end{equation*}\subsubsection*{Demostración}

\sphinxAtStartPar
Basta con demostrar que se satisface la ecuación de evolución y la condición de contorno
\label{equation:docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:9d5d8bb5-f010-441c-a5e9-9254dd2cb06f}\begin{eqnarray}
\frac{d}{dt}U(t,t_0) &=& \frac{d}{dt} \exp\left({-\frac{i}{\hbar} (t-t_0)H}\right)
    \nonumber\\ \rule{0mm}{6mm}
   &=& \frac{d}{dt}\left( I +(t-t_0)\left(-\frac{i}{\hbar} H\right) + \frac{1}{2!} 
    (t-t_0)^2\left(-\frac{i}{\hbar} H\right)^2  + ...\right) \nonumber\\ \rule{0mm}{6mm}
    &=& 0 +  \left(-\frac{i}{\hbar} H\right) +  (t-t_0)\left(-\frac{i}{\hbar} H\right)^2  + ... \nonumber\\ \rule{0mm}{6mm}
&=&  \left(-\frac{i}{\hbar} H\right)\left( I + (t-t_0) \left(-\frac{i}{\hbar} H\right) + ...\right)
  \nonumber \\ \rule{0mm}{6mm} 
&=& \left(-\frac{i}{\hbar} H\right) \exp\left({-\frac{i}{\hbar} (t-t_0)H}\right)    \nonumber\\ \rule{0mm}{6mm}
&=& -\frac{i}{\hbar} H \,  U(t,t_0)
\end{eqnarray}
\sphinxAtStartPar
Además
\$\(
U(t_0,t_0) =  \exp\left({-\frac{i}{\hbar} (t_0-t_0)H}\right)=\exp(0) = I
\)\$

\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Notar}

\sphinxAtStartPar
Que la cantidad \({-\frac{i}{\hbar} (t-t_0) H }\) es adimensional
\$\(
\frac{1}{\hbox{J}\cdot \hbox{s}}\hbox{s}\cdot\hbox{J} = 1
\)\$

\sphinxAtStartPar
Es decir, es un número puro. Por eso podemos exponenciarla. El operador de evolución \(U(t,t_0)\) es, por tanto, también, una magnitud adimensional.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Escribe una función psi(t,psi0,H) que reciba como argumentos el array psi0 de componentes de \(\ket{\psi(0)}\), una matriz hermítica H, y un valor de t, y devuelva un vector columna correspondiente a \(\ket{\psi(t)}\). Considera \(\hbar=1\).
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{psi}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,}\PYG{n}{psi0}\PYG{p}{,}\PYG{n}{H}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{lpsi} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}
    \PYG{n}{lH} \PYG{o}{=} \PYG{n}{H}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
    \PYG{k}{assert} \PYG{n}{lpsi} \PYG{o}{==} \PYG{n}{lH}
    
    \PYG{n}{psi0ket} \PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{n}{lpsi}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{psitket} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{expm}\PYG{p}{(}\PYG{o}{\PYGZhy{}} \PYG{l+m+mi}{1}\PYG{n}{j}\PYG{o}{*}\PYG{n}{t}\PYG{o}{*}\PYG{n}{H}\PYG{p}{)}\PYG{p}{,}\PYG{n}{psi0ket}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{psitket}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Ejercicio}

\sphinxAtStartPar
Crea un Hamiltoniano aleatorio \(2\times 2\) y considera que la base en la que está escrito es \(\{\ket{0},\ket{1}\}\). Partiendo de cualquiera de ellos, grafica las probabilidades de permanencia \(p(\ket{0}\to \ket{0})\) y de transición \(p(\ket{0}\to \ket{1})\) como funciones del tiempo (considera que \(\hbar = 1\) por simplicidad). Grafica también el valor esperado de \(H\) en ambos estados como función del tiempo. Observa el resultado e intenta explicar por qué es así.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{linalg} \PYG{k+kn}{import} \PYG{n}{expm}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ definamos un Hamiltoniano }\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{random}\PYG{o}{.}\PYG{n}{randn}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{1}\PYG{n}{j}
\PYG{n}{A} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{asmatrix}\PYG{p}{(}\PYG{n}{A}\PYG{p}{)}
\PYG{n}{H} \PYG{o}{=} \PYG{n}{A} \PYG{o}{+} \PYG{n}{A}\PYG{o}{.}\PYG{n}{getH}\PYG{p}{(}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{estado inicial |psi(0)\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{psi0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}

\PYG{n}{tend} \PYG{o}{=} \PYG{l+m+mi}{2}
\PYG{n}{steps} \PYG{o}{=} \PYG{l+m+mi}{100}
\PYG{n}{tlist}\PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{tend}\PYG{p}{,} \PYG{n}{steps} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{estado a tiempo t |psi(t)\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{psitketlist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{psi}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{psi0}\PYG{p}{,}\PYG{n}{H}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{probabilidades}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{p00list} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{psitketlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{p01list} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{psitketlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}  \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}

\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{valores esperados \PYGZlt{}H\PYGZgt{}(t)}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{psitbralist}\PYG{o}{=} \PYG{p}{[}\PYG{n}{psitketlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{conj}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{reshape}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\PYG{n}{Hvevtlist} \PYG{o}{=} \PYG{p}{[}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{psitbralist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,}\PYG{n}{psitketlist}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{real}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{)}\PYG{p}{)}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Graficamos

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax1} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:red}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{time (s)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{p(0i)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{,}\PYG{n}{p00list}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{,}\PYG{n}{p01list}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:orange}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{labelcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{ax2} \PYG{o}{=} \PYG{n}{ax1}\PYG{o}{.}\PYG{n}{twinx}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} instantiate a second axes that shares the same x\PYGZhy{}axis}

\PYG{n}{color} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:blue}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}H\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} we already handled the x\PYGZhy{}label with ax1}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{tlist}\PYG{p}{,}\PYG{n}{Hvevtlist}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{tick\PYGZus{}params}\PYG{p}{(}\PYG{n}{axis}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{labelcolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tab:blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} otherwise the right y\PYGZhy{}label is slightly clipped}
\PYG{n}{plt}\PYG{o}{.}\PYG{n}{show}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{8d33174182ce6a48cccf36dfee95370f77777d76a318cc5005681a49f3b8d3b0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Evolución en la base autoestados de H}
\label{\detokenize{docs/Part_01_Formalismo/Chapter_02_01_Fundamentos_MC_myst:evolucion-en-la-base-autoestados-de-h}}
\sphinxAtStartPar
Sea \(\{\ket{n}\}\) una base de autoestados de \(H \, \Rightarrow \,H \ket{n} = E_n \ket{n}~~~~n=1,..,N.\)

\sphinxAtStartPar
En esta base \(H\) es una matriz \(H_{mn}\) diagonal
\begin{equation*}
\begin{split}
H_{mn} =  \begin{bmatrix} E_0 &  & & \\  & E_1 &  & \\ & & \ddots & \\ & & & \end{bmatrix} =E_m \delta_{mn} \, .
\end{split}
\end{equation*}
\sphinxAtStartPar
Entonces la matriz de evolución es también diagonal
\begin{equation*}
\begin{split}
U_{mn} = \exp\left(-\frac{i}{\hbar}t H_{mn}\right) = 
 \begin{bmatrix} e^{-\frac{i}{\hbar}t E_0} &  & & \\  & e^{-\frac{i}{\hbar} t E_1}  &  & \\ & & \ddots & \\ & & & \end{bmatrix} = e^{-\frac{i}{\hbar} t  E_m }\delta_{mn} \, .
\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{En resumen}
\begin{itemize}
\item {} 
\sphinxAtStartPar
La evolución temporal de un autoestado de la energía es trivial (es una fase global)

\end{itemize}
\begin{equation*}
\begin{split}
U(t,0)\ket{n} = e^{-\frac{i}{\hbar} t E_n} \ket{n}\, .
\end{split}
\end{equation*}\begin{itemize}
\item {} 
\sphinxAtStartPar
Esta fase deja de ser trivial cuando afecta a una combinación lineal. La forma más eficaz de calcular la evolución de un estado arbitrario es expresarla en la base \(\{\ket{n}\}\).
Es decir, si a \(t=0\)

\end{itemize}
\begin{equation*}
\begin{split}
\ket{\psi(t=0)} = \sum_n c_n \ket{n} \, 
\end{split}
\end{equation*}
\sphinxAtStartPar
entonces, a tiempo \(t\)
\begin{equation*}
\begin{split}
\ket{\psi(t)} = \sum_n c_n e^{-\frac{i}{\hbar}E_n} \ket{n} \, .
\end{split}
\end{equation*}\end{sphinxadmonition}







\renewcommand{\indexname}{Index}
\printindex
\end{document}