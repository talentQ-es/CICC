{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "f0e9603c",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "> {sub-ref}`today` | {sub-ref}`wordcount-minutes` min read\n",
    "\n",
    "::::{figure} ../figuras/logos/Logo_TalentQ_Azul.png\n",
    ":width: 150px\n",
    ":align: right\n",
    "::::\n",
    "\n",
    "\n",
    "# Fundamentos de Mecánica Cuántica \n",
    "\n",
    "\n",
    "$ \\newcommand{\\bra}[1]{\\langle #1|} $\n",
    "$ \\newcommand{\\ket}[1]{|#1\\rangle} $\n",
    "$ \\newcommand{\\braket}[2]{\\langle #1|#2\\rangle} $\n",
    "$ \\newcommand{\\ketbra}[2]{| #1\\rangle\\! \\langle #2|} $\n",
    "$ \\newcommand{\\tr}{{\\rm tr}} $\n",
    "$ \\newcommand{\\i}{{\\color{blue} i}} $ \n",
    "$ \\newcommand{\\Hil}{{\\cal H}} $\n",
    "$ \\newcommand{\\V}{{\\cal V}} $"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8feb3abd",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "%run ../macro_tQ.py\n",
    "import sys\n",
    "sys.path.append('../')\n",
    "import macro_tQ as tQ\n",
    "\n",
    "import numpy as np\n",
    "import scipy.linalg as la\n",
    "from IPython.display import display,Markdown,Latex\n",
    "import matplotlib.pyplot as plt\n",
    "from qiskit.tools.visualization import array_to_latex\n",
    "import copy "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "974bbaca",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## Axiomas"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "26a4a140",
   "metadata": {
    "slideshow": {
     "slide_type": "-"
    }
   },
   "source": [
    "Los axiomas de la Mecánica Cuántica son unos pilares heurísticos, es decir,  basados en la experimentación. La axiomática más aceptada es   la denominada  <i>interpretación de Copenhagen</i> \n",
    "\n",
    "<a id='axiomas-I'></a>\n",
    "::::::{card} \n",
    "<b>Postulado I</b>: </i>Vector de estado</i> \n",
    "\n",
    "^^^\n",
    "<br>    \n",
    "En un instante, $t$, la <i>máxima información accesible</i> de un sistema cuántico <i>aislado</i> está asociada a un vector $\\ket{\\psi}$ de norma unidad, perteneciente a un espacio de Hilbert $\\Hil$\n",
    "\n",
    "::::::\n",
    " La palabra *estado* es engañosa por cuanto parece indicar que el sistema *está* en alguna estado concreto definido por un valor concreto de sus propiedades, ¡esto no es así!  El vector de estado se conoce también con el nombrede  *función de onda*\n",
    "<br>\n",
    "\n",
    "Dos vectores que difieran en una *fase global* contienen idéntica informacuón y, por tanto,  representan al mismo estado: ningún experimento permite distinguirlos\n",
    "<br>\n",
    "$$\n",
    "\\ket{\\psi} \\sim \\ket{\\psi'} =  e^{i\\varphi}\\ket{\\psi} \\, ,\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a473c130",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "    \n",
    "La dinámica de un sistema cuántico  está contenido en un *operador hermítico* $H = H^\\dagger$ que se denomina **operador Hamiltoniano**\n",
    "\n",
    "\n",
    "\n",
    "El operador Hamiltoniano  *gobierna su evolución*. Supongamos que el sistema se prepara a $t=0$ en un cierto estado $\\ket{\\psi(0)}$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0aa6be34",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "::::::{card} \n",
    "<b>Postulado  II</b>: </i>Evolución con el tiempo</i> \n",
    "\n",
    "^^^\n",
    "<br>\n",
    "<br>    \n",
    "El cambio continuo en el tiempo de  $\\ket{\\psi(t)}$ de un sistema cuya dinámica obedece a un Hamiltoniano $H(t)$,  es <i>determinista</i> y es solución de la <i>Ecuación de Schrödinger</i>\n",
    "<br> \n",
    "<br>\n",
    "$$\n",
    " \\frac{\\partial\\ket{\\psi(t)}}{\\partial t} =-\\frac{i}{\\hbar} H(t) \\ket{\\psi(t)} \\, \\label{eqschr}\n",
    "$$\n",
    "\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7a967f13",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "La ecuación de Schrödinger es una ecuación diferencial ordinaria (una sola variable) para un vector. Dada una contición inicial $\\ket{\\psi(t=0)} = \\ket{\\psi_0}$, la solución $\\ket{\\psi(t)}$ para todo $t$ es única.\n",
    "\n",
    "Por tanto, la evolución del estado es *determinista*. Es en la medida sobre el sistema donde la Mecánica Cuántica muestra su carácter probabilístico. Vamos a mencionar en este capítulo la medida proyectiva, que es el caso más simple. Estudiaremos  en el [capítulo 5](../05_Fun_Info_Cuant/Fun_Info_Cuant.ipynb) que son un caso particular del tipo más general de medidas posible  "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "87df312a",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "::::::{card} \n",
    "<b>Postulado III</b>: </i>Medidas proyectivas, o de Von Neumann</i> \n",
    "\n",
    "^^^\n",
    "<a id='postul_III_medida'></a>\n",
    "<br>\n",
    "<br>    \n",
    "- A una magnitud física medible le está asociado   un operador hermítico  $ A= A^\\dagger$ que denominamos <b>observable</b>.\n",
    "<br>\n",
    "<br>\n",
    "- Los resultados de una medición no pueden dar como resultado nada más que uno de los valores propios de $A \\Rightarrow \\lambda_n$.\n",
    "<br>    \n",
    "<br>    \n",
    "- <i> Regla de Born</i>: La probabilidad de obtener  el autovalor $\\lambda_k$ como resultado de una cierta medición, viene dada por\n",
    "la expresión\n",
    "<br><br>\n",
    "$$\n",
    "p(\\lambda_k)~ = ~|\\braket{\\lambda_k}{\\psi}|^2\n",
    "$$ \n",
    "donde $\\ket{\\lambda_k}$ es el autovector asociado. \n",
    "\n",
    "\n",
    "::::::\n",
    "    "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "12f70c42",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "- la intepretación probabilística de las componentes del *vector de estado* las que fuerzan a que sea unitario. Efectivamente \n",
    "como la suma de todas las probabilidades debe ser igual a la unidad\n",
    "$$\n",
    "1 = \\sum_k \\lambda_k = \\sum_k \\braket{\\psi}{\\lambda_k}\\braket{\\lambda_k}{\\psi} = \\bra{\\psi}\\left(\\sum_k\\ketbra{\\lambda_k}{\\lambda_k}\\right) \\ket{\\psi} = \\braket{\\psi}{\\psi}\n",
    "$$\n",
    "\n",
    "- que las magnitudes medibles son números reales, exige que el operador $A$ asociado a un observable deba ser hermítico \n",
    "\n",
    "La fórmula dada para $p(\\lambda_k)$  es cierta cuando el autovalor en cuestion es *no degenerado*. \n",
    "Cuando $\\lambda_k$ tiene degeneración $d_k$ debe generalizarse:\n",
    "\n",
    "$$\n",
    "\\begin{array}{rcl}\n",
    "p(\\lambda_k)~ &=& ~ \\sum_{a=1}^{d_k}|\\braket{\\lambda^a_k}{\\psi}|^2 = \\bra{\\psi}\\left(\n",
    " \\sum_{a=1}^{d_k}\\ketbra{\\lambda^a_k}{\\lambda^a_k}\\right) \\ket{\\psi}\\nonumber\\\\\n",
    "&=&  \\bra{\\psi}P_k\\ket{\\psi} \\rule{0mm}{7mm}\\\\\n",
    "\\end{array}\n",
    "$$\n",
    "\n",
    "La última expresión revela que $p(\\lambda_k)$ no es más que el *valor esperado del proyector* $P_k = P^2_k$ en el estado del sistema anterior a la medida. \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f5921617",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "::::::{admonition} Nota\n",
    ":class: note\n",
    "\n",
    "\n",
    "\n",
    "- *Muy importante*:  $\\{\\lambda_k,p(\\lambda_k)\\}$ no es una variable <i>pseudo-aleatoria</i> sino, probablemente, la única  variable intrínsecamente aleatoria que existe en la naturaleza.  \n",
    "    \n",
    "    \n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f2012fa4",
   "metadata": {},
   "source": [
    "El hecho de medir tiene consecuencias *irreversibles* sobre el sistema medido. Este hecho es, sin duda, el efecto más diferenciador de la Mecánica Cuántica sobre la clásica: no existe el concepto de *partícula de prueba*, aquella que obtiene información de un sistema sin perturbarlo, como los planetas en el sistema solar"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b0d8313e",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "::::::{card} \n",
    "<b>Postulado IV</b>: </i>Colapso de la función de  onda</i> \n",
    "\n",
    "^^^\n",
    "<br>  \n",
    "Si el resultado de una medida efectuada sobre un sistema en un estado $\\ket{\\psi}$  ha sido  $\\lambda_n$,  inmediatamente después de la medida, el estado del sistema viene dado por el vector propio asociado  \n",
    "$\\ket{\\lambda_n} \\in \\Hil$, normalizado $|\\braket{\\lambda_n}{\\lambda_n}|=1$\n",
    "   \n",
    "::::::\n",
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4da246bd",
   "metadata": {},
   "source": [
    "El sistema del medidor y el sistema medido, son a su vez un sistema aisado ¿por qué no parecen obedecer a las reglas de un sistema cuántico? ¿cuál es el límite que marca la distinción entre un objeto cuántico y uno clásico capaz de hacer colapsar el estado de otro? El axioma del *colapso de la función de onda* es heurístico y ha suscitado intensos debates desde su formulación. El más famoso es el de la paradoja del Gato de Schrödinger.\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1f0280c4",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "## Medidas y valores esperados\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dd282294",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "En Mecánica Cuántica especificamos un estado en las componentes de la expansión de un estado en *una base* ortonormal.\n",
    "Existen infinitas bases posibles para expresar un vector. ¿Qué base es la mejor? La respuesta es que depende del proceso que estudiemos.\n",
    "\n",
    "Por ejemplo, si el proceso es *la medida* de un cierto observable $A=A^\\dagger$, el resultado de nuestra medición sólo puede ser uno de los *valores propios* $\\lambda_i$\n",
    "$$\n",
    "A \\ket{\\lambda_k} = \\lambda_k \\ket{\\lambda_k}\\, \n",
    "$$\n",
    "donde $\\ket{\\lambda_k}$ son los autovectores ${k=1,2,...}$ que forman una base ortonormal. Ésta es la base natural adaptada a procesos de medida de $A$. En particular para conocer *con qué probabilidad* se producirá cada resultado, expandiremos el estado en dicha base de autoestados  \n",
    "\n",
    "$$\n",
    "\\ket{\\psi} = \\sum_{i=1}^N a_i \\ket{\\lambda_i}\\, \n",
    "$$\n",
    "\n",
    "El axioma IV (regla de Born) afirma que <i>la probabilidad de aparición</i> del resultado $\\lambda_i$ es precisamente \n",
    "\n",
    "$$\n",
    "p(\\lambda_i)=|\\braket{\\lambda_i}{\\psi}|^2  = |a_i|^2 \\, \n",
    "$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "77dc80b2",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "La forma de tener acceso experimental a los números $p(\\lambda_i)$  es mediante la **repetición estadística**. Si efectuamos la medida un número $n$ de veces con $n\\to \\infty$, y contamos la frecuencia de aparición de los distintos $\\lambda_i$\n",
    "en el límite $n\\to \\infty$ dicha frecuencia experimental convergerá a la probabilidad teórica\n",
    "\n",
    "$$\n",
    "\\lim_{n\\to\\infty} \\frac{n(\\lambda_i)}{n} =  p(\\lambda_i)  = |a_i|^2   \\, .\n",
    "$$\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "db718426",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "Vemos que, mediante repetición estadística, solamente podemos recuperar el *módulo de las amplitudes* \n",
    "\n",
    "$$\n",
    "|a_i| = \\lim_{n\\to\\infty} \\sqrt{\\frac{n(\\lambda_i)}{n} }\n",
    "$$ \n",
    "<br>\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b3caac07",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "::::::{admonition} Notar\n",
    ":class: note\n",
    "\n",
    "\n",
    "    \n",
    "- En Computación Cuántica, almacenamos la información en las amplitudes $a_i$ en una base dada (la base computacional). Vemos que sólamente su módulo $|a_i|$ es recuperable a través de medidas.\n",
    "    \n",
    "    \n",
    "- Cada vez que seleccionamos un estado $\\ket{\\psi}$, y un observable $A$, se genera una variable aleatoria $(\\lambda,p(\\lambda))\\, \\to $ en cada medida de $A$ sobre $\\ket{\\psi}$ obtenemos un autovalor $\\lambda_i$ con una probabilidad $p(\\lambda_i)$.\n",
    "La repetición del experimento permite reconstruir estimadores estadísticos. \n",
    "  \n",
    "\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6073e1bf",
   "metadata": {},
   "source": [
    "::::::{admonition} Ejercicio\n",
    ":class: tip\n",
    "\n",
    "<br>\n",
    "Generaliza las expresiones anteriores al caso en que los autovalores $\\lambda_k$ puedan ser  $d_k$ veces degenerados.\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "19266151",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Valores esperados\n",
    "<a id='valores_esperados'></a>\n",
    "\n",
    "Rescribamos la probabilidad de encontrar $\\lambda_k$ en el caso de que sea $d_k$ veces degenerado\n",
    "\n",
    "$$\n",
    "\\begin{array}{rcl}\n",
    "p(\\lambda_k) &=& \\sum_{a=1}^{d_k} |\\braket{\\lambda^a_k}{\\psi}|^2  = \n",
    "\\sum_{a=1}^{d_k} \\braket{\\psi}{\\lambda^a_k}\\braket{\\lambda^a_k}{\\psi} \\nonumber\\\\ \\rule{0mm}{8mm}\n",
    "&=&\\bra{\\psi} \\left( \\sum_{a=1}^{d_k} \\ket{\\lambda^a_k}\\bra{\\lambda^a_k}  \\right) = \\bra{\\psi}P_k \\ket{\\psi} \n",
    "\\end{array}\n",
    "$$\n",
    "donde \n",
    "\n",
    "$$\n",
    "P_k = \\sum_{a=1}^{d_k} \\ket{\\lambda^a_k}\\bra{\\lambda^a_k}\n",
    "$$\n",
    "es el proyector sobre el subespacio propio"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e1e41344",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "\n",
    "Por el *valor esperado* $\\langle A\\rangle$ del *observable* $A$ en el estado $\\ket{\\psi}$, entendemos el *valor medio* de la variable aleatoria $\\lambda_n$ obtenida por el método descrito. \n",
    "<br>\n",
    "\n",
    "\\begin{eqnarray}\n",
    "\\langle A\\rangle &= &  \\sum_k \\lambda_k p(\\lambda_k)\n",
    "   =  \\sum_k \\lambda_k \\bra{\\psi}P_k\\ket{\\psi}  \n",
    "&=& \\bra{\\psi}\\left(\\sum_k \\lambda_k P_k  \\right) \\ket{\\psi} \n",
    "\\end{eqnarray}\n",
    "\n",
    "Reconocemos entre paréntesis la descomposición espectral de $A$. Llegamos así a la siguiente expresión para el valor esperado de un observable $A$ en un estado $\\ket{\\psi}$\n",
    "<br>\n",
    "::::::{card} \n",
    "<b>Teorema</b>:  \n",
    "\n",
    "^^^\n",
    "$$\\langle A \\rangle=\\bra{\\psi}A \\ket{\\psi} $$\n",
    "::::::\n",
    "\n",
    "En particular, las probabilidades mismas se pueden expresar como *valores esperados del proyector asociado*\n",
    "\n",
    "$$\n",
    "p(\\lambda_k ) =  \\bra{\\psi}P_k\\ket{\\psi} = \\langle P_k\\rangle \n",
    "$$\n",
    "El espectro de un observable está formado por números reales que podemos ordenar $\\lambda_{min}<...<\\lambda_{max}$.\n",
    "El valor esperado de un observable en uno de sus autoestados coincide con el autovalor asociado\n",
    "\n",
    "$$\n",
    "\\bra{\\lambda_i}A \\ket{\\lambda_i} = \\bra{\\lambda_i}\\lambda_i \\ket{\\lambda_i}  = \\lambda_i \\braket{\\lambda_i}{\\lambda_i} = \\lambda_i\n",
    "$$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7185b97",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "El valor esperado de un observable $A$ está acotado entre sus valores propios mínimo y máximo\n",
    "\n",
    "$$\n",
    "\\lambda_{min} \\leq \\bra{\\psi}A\\ket{\\psi} \\leq \\lambda_{max}\n",
    "$$\n",
    "\n",
    "y las desigualdades anteriores se saturan en los autoestados correspondientes $\\ket{\\psi} = \\ket{\\lambda_{max/min}}$\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2747ef46",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "#### Desviación estándar\n",
    "<a id='desviacion_estandar'></a>\n",
    "\n",
    "La *varianza*  es la media de la desviación cuadrática de la variable aleatoria $(\\lambda,p(\\lambda))$ es decir \n",
    "<br>\n",
    "<br>\n",
    "$$\n",
    "~~\\sigma ^2 = \\overline{(\\lambda_i-\\bar\\lambda_i)^2}= \\overline{\\lambda^2} - \\overline{\\lambda}^2\n",
    "$$\n",
    "de aquí se sigue, para la desviación estándar"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e713036b",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "::::::{card} \n",
    "<b>Teorema</b>:  \n",
    "\n",
    "^^^\n",
    "<br>   \n",
    "$$ \\sigma = \\sqrt{\\bra{\\psi}A^2\\ket{\\psi} - \\bra{\\psi} A\\ket{\\psi}^2}\n",
    "$$\n",
    "\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0e68eaff",
   "metadata": {},
   "source": [
    "Evaluada en un estado propio $\\ket{\\lambda_i}$, la varianza de un operador es cero\n",
    "\n",
    "$$\n",
    "\\sigma^2 = \\bra{\\lambda_i}A^2\\ket{\\lambda_i} - \\bra{\\lambda_i} A\\ket{\\lambda_i}^2 = \\bra{\\lambda_i}\\lambda_i^2\\ket{\\lambda_i} - \\bra{\\lambda_i} \\lambda_i\\ket{\\lambda_i}^2 = 0\n",
    "$$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "7fadb4b6",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "outputs": [],
   "source": [
    "' funcion que toma una matriz y un vector normalizado  y devuelve el valor esperado y la desviación '\n",
    "def vev_sig(A, ket):\n",
    "\n",
    "    assert np.round(np.sqrt(np.dot(ket.conj().T,ket)[0,0]).real,5)  == 1. # chequeamos que la norma es unidad\n",
    "    bra = ket.conj().T\n",
    "    \n",
    "    'el valor esperado'\n",
    "    vev = np.dot(bra,np.dot(A,ket))[0,0].real\n",
    "   \n",
    "    'la varianza'\n",
    "    A2 = np.dot(A,A)\n",
    "    var= np.dot(bra,np.dot(A2,ket))[0,0] - vev**2\n",
    "    sig = np.sqrt(np.abs(var.real))\n",
    "    \n",
    "    return(np.round(vev,5), np.round(sig,10))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "1c99f7bd",
   "metadata": {
    "run_control": {
     "marked": false
    },
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-3.8847, -0.7933,  2.318 ])"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "' definamos una matriz hermítica '\n",
    "#np.random.seed(10) \n",
    "A = np.matrix(np.random.randn(3,3) + np.random.randn(3,3)*1j)\n",
    "A +=  A.getH()\n",
    "eigvals, eigvecs = np.linalg.eigh(A)\n",
    "' mostramos los autovalores '\n",
    "np.round(eigvals,4)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ae03d791",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "A continuación evaluamos el valor esperado en un vector aleatorio, y en dos autovectores de $A$"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "818443b7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<A>=  -3.04824  sigma =  0.0\n"
     ]
    }
   ],
   "source": [
    "'definamos un ket'\n",
    "vec1 = np.random.randn(len(A),1)   # este es un autovector aleatorio\n",
    "vec2 = eigvecs[:,0]           # este es el autovector de autovalor mínimo\n",
    "vec3 = eigvecs[:,-1]          # éste es un autovector de autovalor máximo\n",
    "\n",
    "ket = vec2       # elegimos uno \n",
    "\n",
    "'normalizado'\n",
    "norma=np.sqrt(np.dot(ket.conj().T,ket)[0,0]).real \n",
    "uket = ket/norma\n",
    "\n",
    "\n",
    "vev, sig = vev_sig(A,uket)\n",
    "\n",
    "print('<A>= ',vev, ' sigma = ', sig)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7cefc218",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "## Evolución temporal"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f8f976eb",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Ecuación de Schrödinger\n",
    "\n",
    "El estado de un sistema $\\ket{\\psi(t)}$ posee la máxima información instantánea accesible de un sistema, es decir, a un tiempo dado $t$. \n",
    "Dado $\\ket{\\psi(t_0)}$ en un instante inicial $t_0$, la evolución posterior obedece a la  ecuación diferencial de Schrödinger\n",
    "\n",
    "$$\n",
    " \\displaystyle \\frac{d}{d t}\\ket{\\psi(t)} =-\\frac{i}{\\hbar} H(t) \\ket{\\psi(t)} \\, .\n",
    "$$\n",
    "\n",
    "\n",
    "Hemos enfatizado el hecho de que, en el caso más general, $H(t)$ puede depender del tiempo.\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "13f94259",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "::::::{admonition} Notar\n",
    ":class: note\n",
    "\n",
    "\n",
    "\n",
    "Las cantidades que entran en la ecuación de Schrödinger *tienen unidades*: \n",
    "\n",
    "- $H$ tiene unidades de *energía*. En el SI (Sistema Iternacional) $\\to$ $\\hbox{Julios = J}$\n",
    "\n",
    "\n",
    "- $t$ tiene unidades de *tiempo*, en el SI $\\to$ $\\hbox{segundos = s}$\n",
    "\n",
    "\n",
    "- $\\hbar$ es la constante de Planck, y  tiene unidades de *acción*= energía $\\times$  tiempo. En el SI  $\\to $ $\\hbox{Julios}\\cdot\\hbox{segundo} =  \\hbox{J}\\cdot\\hbox{s}$. $~$ Se trata de una *cantidad universal* \n",
    "$$\n",
    "\\boxed{\\hbar = 1.054\\times 10^{-34}~~ \\hbox{J}\\cdot\\hbox{s}}\n",
    "$$\n",
    "\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79a525f3",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "#### Conservación de la probabilidad.\n",
    "\n",
    "La *hermiticidad* de $H$ se relaciona directamente con la interpretación probabilística de $\\ket{\\psi}$.\n",
    "\n",
    "::::::{card} \n",
    "<b>Teorema</b>:  \n",
    "\n",
    "^^^\n",
    "<br>\n",
    "En la evolución temporal se conserva la norma del vector de estado\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "493b0f30",
   "metadata": {
    "slideshow": {
     "slide_type": "skip"
    }
   },
   "source": [
    "<details><summary><p style=\"text-align:left\"> >><i>Prueba</i> </p></summary>\n",
    "\n",
    "\\begin{eqnarray*}\n",
    "\\frac{d}{dt}\\|\\ket{\\psi}\\|^2 = \\frac{d}{dt}\\braket{\\psi(t)}{\\psi(t)} &=& \\left(\\rule{0mm}{3mm}\\frac{d}{dt}\\bra{\\psi(t)}\\right)\\ket{\\psi(t)} + \n",
    "\\bra{\\psi(t)}\\left(\\frac{d}{dt}\\ket{\\psi(t)} \\right)\\nonumber\\\\\n",
    "&=& \\left(\\bra{\\psi(t)}\\frac{i}{\\hbar}H^\\dagger\\right)\\ket{\\psi(t)} + \\bra{\\psi(t)}\\left(-\\frac{i}{\\hbar}H\\ket{\\psi(t)} \\right) \\nonumber\\\\\n",
    "&=&\\frac{i}{\\hbar} \\bra{\\psi(t)}(H^\\dagger - H)\\ket{\\psi(t)} = 0\n",
    "\\end{eqnarray*}\n",
    "<br>\n",
    "Es decir: $\\|\\ket{\\psi}\\|$ no cambia con el tiempo, y \n",
    "esto implica que la norma de $\\ket{\\psi(t)}$ se conserva $\\Rightarrow 1 = \\|\\ket{\\psi(0)}\\| =\\|\\ket{\\psi(t)}\\|$\n",
    "</details>   \n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "57d3434a",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Operador de Evolución\n",
    "<a id='operador_evolucion'></a>\n",
    "\n",
    "La conservación de la norma implica que la evolución $\\|\\ket{\\psi(0)\\|} =\\|\\ket{\\psi(t)}\\|$ es un *proceso unitario*. \n",
    "En otras palabras, debe existir un operador unitario \n",
    "\n",
    "$$\n",
    "U(t,t_0)^{-1}= U(t,t_0)^\\dagger \n",
    "$$\n",
    "\n",
    "que lleve el estado inicial al actual a tiempo $t$\n",
    "\n",
    "$$\n",
    " U(t,t_0): \\ket{\\psi(t_0)}~~ \\to~~ \\rule{0mm}{3.5mm} \\ket{\\psi(t)} = U(t,t_0)\\ket{\\psi(t_0)}\n",
    "$$"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e6e0d38f",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "\n",
    "::::::{admonition} Notar\n",
    ":class: note\n",
    "\n",
    "\n",
    "<br>\n",
    "    \n",
    "El operador de evolución satisface las siguientes propiedades\n",
    "\n",
    " -  $U(t_0,t_0) = I$ \\, .\n",
    " \n",
    "\n",
    " -  transitividad:  $U(t,t_1)U(t_1,t_0)= U(t,t_0)$\n",
    " \n",
    " \n",
    " -  invertibilidad: $U(t,t_0)^{-1} = U(t_0,t)$\n",
    " \n",
    "\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eb031dbe",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "Evidentemente, el operador de evolución debe estar relacionado con el Hamiltoniano, que es quien gobierna la dinámica. Veamos a ver que hay una ecuación de Schrödinger también para el operador de evolución\n",
    "\n",
    "::::::{card} \n",
    "<b>Teorema</b>:  \n",
    "\n",
    "^^^\n",
    "<br>\n",
    "El operador de evolución satisface la siguiente ecuación de evolución\n",
    "<br>\n",
    "$$\n",
    " \\frac{d}{dt}U(t,t_0) = -\\frac{i}{\\hbar} H(t)\\, U(t,t_0)\n",
    "$$\n",
    "\n",
    "::::::\n",
    "<details><summary><p style=\"color:grey;text-align:right\"> >> <i>Demostración</i> </p></summary>\n",
    "Tomando la derivada temporal de la ecuación $\\ket{\\psi(t)} = U(t,t_0)\\ket{\\psi(t_0)}$, que define $U(t,t_0)$, tenemos para cada miembro\n",
    "\n",
    "$$\n",
    "\\begin{array}{rcl}\n",
    "\\frac{d}{dt}\\ket{\\psi(t)} &~=~& -\\frac{i}{\\hbar}  H(t)\\ket{\\psi(t)} = -\\frac{i}{\\hbar} H(t)U(t,t_0)\\ket{\\psi(t_0)}  \\nonumber\\\\\n",
    "\\frac{d}{dt}U(t,t_0)\\ket{\\psi(t_0)} &~=~& \\left(\\frac{d}{dt}U(t,t_0)\\right)\\ket{\\psi(t_0)}\n",
    "\\end{array}\n",
    "$$\n",
    "\n",
    "Igualando ambas expresiones, y teniendo en cuanto que $\\ket{\\psi_0}$ es arbitrario, obtenemos la ecuación deseada.\n",
    "</details>"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6646481c",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "#### $H$ independiente del tiempo\n",
    "\n",
    "Cuando $H$ no depende del tiempo podemos dar una expresión analítica para el operador de evolución"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f450aa40",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "::::::{card} \n",
    "<b>Teorema</b>:  \n",
    "\n",
    "^^^\n",
    "<br>    \n",
    "Para un hamiltoniano $H$ independiente del tiempo, el operador de evolución $U(t,t_0)$ es\n",
    "<br>\n",
    "$$\n",
    "U(t,t_0) = \\exp\\left({-\\frac{i}{\\hbar} (t-t_0)H}\\right)\n",
    "$$\n",
    "\n",
    "::::::\n",
    "<details><summary><p style=\"color:grey;text-align:right\"> >> <i>Demostración</i> </p></summary>\n",
    "Basta con demostrar que se satisface la ecuación de evolución y la condición de contorno\n",
    "\n",
    "$$\n",
    "\\begin{array}{rcl}\n",
    "\\frac{d}{dt}U(t,t_0) &=& \\frac{d}{dt} \\exp\\left({-\\frac{i}{\\hbar} (t-t_0)H}\\right)\n",
    "    \\nonumber\\\\ \\rule{0mm}{6mm}\n",
    "   &=& \\frac{d}{dt}\\left( I +(t-t_0)\\left(-\\frac{i}{\\hbar} H\\right) + \\frac{1}{2!} \n",
    "    (t-t_0)^2\\left(-\\frac{i}{\\hbar} H\\right)^2  + ...\\right) \\nonumber\\\\ \\rule{0mm}{6mm}\n",
    "    &=& 0 +  \\left(-\\frac{i}{\\hbar} H\\right) +  (t-t_0)\\left(-\\frac{i}{\\hbar} H\\right)^2  + ... \\nonumber\\\\ \\rule{0mm}{6mm}\n",
    "&=&  \\left(-\\frac{i}{\\hbar} H\\right)\\left( I + (t-t_0) \\left(-\\frac{i}{\\hbar} H\\right) + ...\\right)\n",
    "  \\nonumber \\\\ \\rule{0mm}{6mm} \n",
    "&=& \\left(-\\frac{i}{\\hbar} H\\right) \\exp\\left({-\\frac{i}{\\hbar} (t-t_0)H}\\right)    \\nonumber\\\\ \\rule{0mm}{6mm}\n",
    "&=& -\\frac{i}{\\hbar} H \\,  U(t,t_0)\n",
    "\\end{array}\n",
    "$$\n",
    "\n",
    "Además\n",
    "\n",
    "$$\n",
    "U(t_0,t_0) =  \\exp\\left({-\\frac{i}{\\hbar} (t_0-t_0)H}\\right)=\\exp(0) = I\n",
    "$$\n",
    "\n",
    "</details>\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1957338e",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "::::::{admonition} Notar\n",
    ":class: note\n",
    "\n",
    "\n",
    "<br>\n",
    "que la cantidad ${-\\frac{i}{\\hbar} (t-t_0) H }$ es adimensional\n",
    "\n",
    "$$\n",
    "\\frac{1}{\\hbox{J}\\cdot \\hbox{s}}\\hbox{s}\\cdot\\hbox{J} = 1\n",
    "$$ \n",
    "\n",
    "Es decir, es un número puro. Por eso podemos exponenciarla. El operador de evolución $U(t,t_0)$ es, por tanto, también, una magnitud adimensional.\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c72f0f24",
   "metadata": {},
   "source": [
    "::::::{admonition} Ejercicio\n",
    ":class: tip\n",
    "\n",
    "<br>\n",
    "Escribe una función <i>psi(t,psi0,H)</i> que reciba como argumentos el array <i>psi0</i> de componentes de $\\ket{\\psi(0)}$, una matriz hermítica <i>H</i>, y un valor de <i>t</i>, y devuelva un vector columna correspondiente a $\\ket{\\psi(t)}$. Considera $\\hbar=1$.\n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "f80bb0e8",
   "metadata": {
    "code_folding": [],
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "outputs": [],
   "source": [
    "def psi(t,psi0,H):\n",
    "    lpsi = len(psi0)\n",
    "    lH = H.shape[0]\n",
    "    assert lpsi == lH\n",
    "    \n",
    "    psi0ket =np.array(psi0).reshape(lpsi,1)\n",
    "    psitket = np.dot(expm(- 1j*t*H),psi0ket)\n",
    "    return psitket"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "15fe0fdd",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "::::::{admonition} Ejercicio\n",
    ":class: tip\n",
    "\n",
    "<br>\n",
    "Crea un Hamiltoniano aleatorio $2\\times 2$ y considera que la base en la que está escrito es $\\{\\ket{0},\\ket{1}\\}$. Partiendo de cualquiera de ellos, grafica las probabilidades de permanencia $p(\\ket{0}\\to \\ket{0})$ y de transición $p(\\ket{0}\\to \\ket{1})$ como funciones del tiempo (considera que $\\hbar = 1$ por simplicidad). Grafica también el valor esperado de $H$ en ambos estados como función del tiempo. Observa el resultado e intenta explicar por qué es así.    \n",
    "::::::\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "b220561e",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "outputs": [],
   "source": [
    "from matplotlib import pyplot as plt\n",
    "from scipy.linalg import expm\n",
    "\n",
    "' definamos un Hamiltoniano '\n",
    "A = np.random.randn(2,2) + np.random.randn(2,2)*1j\n",
    "A = np.asmatrix(A)\n",
    "H = A + A.getH()\n",
    "\n",
    "'estado inicial |psi(0)>'\n",
    "psi0 = [1,0]\n",
    "\n",
    "tend = 2\n",
    "steps = 100\n",
    "tlist= np.linspace(0,tend, steps + 1)\n",
    "\n",
    "'estado a tiempo t |psi(t)>'\n",
    "psitketlist = [psi(tlist[i],psi0,H) for i in range(len(tlist))]\n",
    "\n",
    "'probabilidades'\n",
    "p00list = [np.abs(psitketlist[i][0,0])  for i in range(len(tlist))]\n",
    "p01list = [np.abs(psitketlist[i][1,0])  for i in range(len(tlist))]\n",
    "\n",
    "'valores esperados <H>(t)'\n",
    "psitbralist= [psitketlist[i].conj().reshape(1,2) for i in range(len(tlist))]\n",
    "Hvevtlist = [np.dot(psitbralist[i],np.dot(H,psitketlist[i])).real[0,0] for i in range(len(tlist))]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4b7e12ca",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "Graficamos"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "d578ddf1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "fig, ax1 = plt.subplots()\n",
    "\n",
    "color = 'tab:red'\n",
    "ax1.set_xlabel('time (s)')\n",
    "ax1.set_ylabel('p(0i)', color= 'tab:red')\n",
    "ax1.plot(tlist,p00list, color= 'tab:red')\n",
    "ax1.plot(tlist,p01list, color= 'tab:orange')\n",
    "ax1.tick_params(axis='y', labelcolor='tab:red')\n",
    "\n",
    "ax2 = ax1.twinx()  # instantiate a second axes that shares the same x-axis\n",
    "\n",
    "color = 'tab:blue'\n",
    "ax2.set_ylabel('<H>', color='tab:blue')  # we already handled the x-label with ax1\n",
    "ax2.plot(tlist,Hvevtlist, color='tab:blue')\n",
    "ax2.tick_params(axis='y', labelcolor='tab:blue')\n",
    "\n",
    "fig.tight_layout()  # otherwise the right y-label is slightly clipped\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ab39f660",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "#### Evolución en la base autoestados de H"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9fdcd243",
   "metadata": {
    "slideshow": {
     "slide_type": "fragment"
    }
   },
   "source": [
    "La forma más eficaz de calcular la evolución de un estado arbitrario es expresarla en la base $\\{\\ket{n}\\}$ de autoestados de $H \\, \\Rightarrow \\,H \\ket{n} = E_n \\ket{n}~~~~n=1,..,N.$ $~$\n",
    "En esta base, $H$ es una matriz $H_{mn}$ diagonal \n",
    "\n",
    "$$\n",
    "H_{mn} =  \\begin{bmatrix} E_0 &  & & \\\\  & E_1 &  & \\\\ & & \\ddots & \\\\ & & & \\end{bmatrix} =E_m \\delta_{mn} \\, .\n",
    "$$\n",
    "\n",
    "Entonces la matriz de evolución es también diagonal \n",
    "\n",
    "$$\n",
    "U_{mn} = \\exp\\left(-\\frac{i}{\\hbar}t H_{mn}\\right) = \n",
    " \\begin{bmatrix} e^{-\\frac{i}{\\hbar}t E_0} &  & & \\\\  & e^{-\\frac{i}{\\hbar} t E_1}  &  & \\\\ & & \\ddots & \\\\ & & & \\end{bmatrix} = e^{-\\frac{i}{\\hbar} t  E_m }\\delta_{mn} \\, .\n",
    "$$\n",
    "\n",
    "La evolución temporal de un autoestado de la energía es trivial (es una fase global)\n",
    "\n",
    "$$\n",
    "U(t,0)\\ket{n} = e^{-\\frac{i}{\\hbar} t E_n} \\ket{n}\\, .\n",
    "$$\n",
    "\n",
    "Esta fase deja de ser trivial cuando afecta a una combinación lineal. . \n",
    "Es decir, si a $t=0$\n",
    "$\n",
    "\\ket{\\psi(t=0)} = \\sum_n c_n \\ket{n} \\, ,\n",
    "$\n",
    "entonces, a tiempo $t$ \n",
    "\n",
    "$$\n",
    "\\ket{\\psi(t)} = \\sum_n c_n e^{-\\frac{i}{\\hbar}E_n} \\ket{n} \\, .\n",
    "$$\n",
    "    "
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.13"
  },
  "nbTranslate": {
   "displayLangs": [
    "*"
   ],
   "hotkey": "alt-t",
   "langInMainMenu": true,
   "sourceLang": "en",
   "targetLang": "fr",
   "useGoogleTranslate": true
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": true,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {
    "height": "calc(100% - 180px)",
    "left": "10px",
    "top": "150px",
    "width": "414.053px"
   },
   "toc_section_display": true,
   "toc_window_display": false
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
